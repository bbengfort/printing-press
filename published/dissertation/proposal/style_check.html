<html>
<head>
<title>style_checker.rb</title>
</head>
<style>
form{width:100%; text-align:center;font-size:10pt;}
input{vertical-align:bottom;margin-left:30px;}
table { width:95%; border-collapse: collapse; font-size:10pt; margin:10px 2.5%}
.spelling th, #mySpelling{background-color:#FFC1C1;}
.capitalize th, #myCapitalize{background-color:#FFF7C1;}
.syntax th, #mySyntax{background-color:#C1E0FF;}
.phrase th, #myPhrase{background-color:#C1FFD1;}
#myUndefined{margin-left:30px;background-color: #eee;}
table, th, td { border: 1px solid black; padding: 5px;}
tr{ width:100%}
div{display:inline;}th{ text-align:left; width: 10%; background-color: #eee;}
td{ width:90%;}
#myTotal{width:100%;margin-left:15px;font-size:10pt;}
table button{float:right; font-size:8pt; border: 1px solid black;width:15px;text-align:center;}
p{ font-size: 10pt; text-align: center;}
</style>
<body><form id="aform"><input type="checkbox" id="inSpelling" name="type" value="spelling" checked="checked"><div id="mySpelling">Spelling</div><input type="checkbox" id="inCapitalize" name="type" value="capitalize" checked="checked"><div id="myCapitalize">Capitalize</div><input type="checkbox" id="inSyntax" name="type" value="syntax" checked="checked"><div id="mySyntax">Syntax</div><input type="checkbox" id="inPhrase" name="type" value="phrase" checked="checked"><div id="myPhrase">Phrase</div><div id="myUndefined">Undefined</div><br /><br /><div id="myTotal"></div></form>
<h1>prelim.tex</h1>
<table id="6b2681c9bf5fd299b115c538a6b359c4f895d606" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 82
, column: 160
)<div class="x"><button onclick="myFunction('6b2681c9bf5fd299b115c538a6b359c4f895d606');">X</button></div></td></tr>
<tr><th>Original</th><td>We contend that current consistency models are highly dependent on the network environment and that existing protocols can fail to achieve progress or provide sufficient consistency for user applications in many environments outside of the data center. Weak or eventual consistency models rely on the fast propagation of updates and therefore consistency is dependent entirely on message latency. Strong, sequential consistency provided by consensus protocols require multiple messages passed through a leader and though it can be shown that such protocols are correct, leadership introduces a bottleneck and partitions can make progress impossible. In user-centric dynamic clouds, responsive consistency models must be developed to take advantage of the changing network environment and respond to user requirements.</td></tr>
<tr><th>Problem</th><td>sufficient</td></tr>
<tr><th>Solution</th><td>phrase "enough"
  </td></tr>
<tr><th>Trigger</th><td> 'sufficient' in /Users/benjamin/.style-check.d/day-gastel:177</td></tr>
</table>
 phrase "enough"
  (matched 'sufficient' in /Users/benjamin/.style-check.d/day-gastel:177)
<table id="bcea64ac392f4639154ed99b2dc9fb767a596c84" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 84
, column: 4
)<div class="x"><button onclick="myFunction('bcea64ac392f4639154ed99b2dc9fb767a596c84');">X</button></div></td></tr>
<tr><th>Original</th><td>We hypothesize that we can provide responsive consistency in heterogenous, mobile topologies through two mechanisms: the federation of multiple consistency models depending on the environment and the load balancing of leadership costs in a quorum through hierarchical consensus. Federated consistency allows heterogenous devices to select a variety of consistency polices that are integrated through a core consensus group. By allowing flexibility locally, devices can make progress through consistency models that take advantage of the current network environment, but still have global guarantees. Hierarchical consensus improves the core consensus group, making it highly available and scalable by balancing leadership to specific decision spaces based on access patterns. Together, we propose that Federated Consistency and Hierarchical Consensus provide a responsive consistency model that will enable an effective multi-user, distributed file system.</td></tr>
<tr><th>Problem</th><td>hypothesize</td></tr>
<tr><th>Solution</th><td>phrase suggest
  </td></tr>
<tr><th>Trigger</th><td> 'hypothesize' in /Users/benjamin/.style-check.d/barrass:18</td></tr>
</table>
 phrase suggest
  (matched 'hypothesize' in /Users/benjamin/.style-check.d/barrass:18)
<table id="d4bb85d7d7f15e05772a835541514f63a6012da9" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 125
, column: 58
)<div class="x"><button onclick="myFunction('d4bb85d7d7f15e05772a835541514f63a6012da9');">X</button></div></td></tr>
<tr><th>Original</th><td>clocks to ensure ``TrueTime'' for sequential ordering or a small
number of master nodes that implement consensus algorithms
~ for locking or ordering</td></tr>
<tr><th>Problem</th><td>a small number of</td></tr>
<tr><th>Solution</th><td>phrase you mean "few"
  </td></tr>
<tr><th>Trigger</th><td> 'a small number of' in /Users/benjamin/.style-check.d/verbose-phrases:7</td></tr>
</table>
 phrase you mean "few"
  (matched 'a small number of' in /Users/benjamin/.style-check.d/verbose-phrases:7)
<table id="c443816d27477aa67b751a7152472841597e64ec" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 131
, column: 363
)<div class="x"><button onclick="myFunction('c443816d27477aa67b751a7152472841597e64ec');">X</button></div></td></tr>
<tr><th>Original</th><td>The focus on data center consistency has led to a centralized approach to data storage, forcing a modality where devices must connect to the cloud for file replication even when files exist in the local area ~. Although this allows systems to ignore annoyances such as local network configuration and decentralized protocols it does present unnecessary overhead in terms of cost and latency. More pernicious, perhaps, is that users must now buy-in and store their data with a single provider that could go out of business or be hacked, which has lead to research in replicating local data with multiple untrusted cloud stores ~. There are more devices than ever before connecting to storage applications, partially because users have multiple, heterogenous devices from wearables to workstations and partially because of the advent of the Internet of Things ~. Cloud storage tends to be application specific, but with more devices and more users, \textit{generalized distributed storage} is required for collaboration and sharing that is not siloed and can be easily accessed by a variety of new platforms. Therefore we see a strong motivation to turn attention back to user-oriented networks of mobile heterogenous devices that do not have the benefit of data center level connectivity.</td></tr>
<tr><th>Problem</th><td>in terms of</td></tr>
<tr><th>Solution</th><td>phrase don't need this.
  </td></tr>
<tr><th>Trigger</th><td> 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136</td></tr>
</table>
 phrase don't need this.
  (matched 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136)
<table id="d8aa23d56e2a437c96dea1209d94d92aa93c5c2d" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 131
, column: 221
)<div class="x"><button onclick="myFunction('d8aa23d56e2a437c96dea1209d94d92aa93c5c2d');">X</button></div></td></tr>
<tr><th>Original</th><td>The focus on data center consistency has led to a centralized approach to data storage, forcing a modality where devices must connect to the cloud for file replication even when files exist in the local area ~. Although this allows systems to ignore annoyances such as local network configuration and decentralized protocols it does present unnecessary overhead in terms of cost and latency. More pernicious, perhaps, is that users must now buy-in and store their data with a single provider that could go out of business or be hacked, which has lead to research in replicating local data with multiple untrusted cloud stores ~. There are more devices than ever before connecting to storage applications, partially because users have multiple, heterogenous devices from wearables to workstations and partially because of the advent of the Internet of Things ~. Cloud storage tends to be application specific, but with more devices and more users, \textit{generalized distributed storage} is required for collaboration and sharing that is not siloed and can be easily accessed by a variety of new platforms. Therefore we see a strong motivation to turn attention back to user-oriented networks of mobile heterogenous devices that do not have the benefit of data center level connectivity.</td></tr>
<tr><th>Problem</th><td>this allows</td></tr>
<tr><th>Solution</th><td>phrase tie more explicitly: This (x) allows...
  </td></tr>
<tr><th>Trigger</th><td> 'This allows' in /Users/benjamin/.style-check.d/my-rules:16</td></tr>
</table>
 phrase tie more explicitly: This (x) allows...
  (matched 'This allows' in /Users/benjamin/.style-check.d/my-rules:16)
<table id="b75a8e1d738225c2bc4b18a5dbc500eb93395719" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 133
, column: 544
)<div class="x"><button onclick="myFunction('b75a8e1d738225c2bc4b18a5dbc500eb93395719');">X</button></div></td></tr>
<tr><th>Original</th><td>We propose to explore consistency mechanisms in \textit{user-centric dynamic clouds}: a multi-user tapestry of mobile, heterogenous devices connected via variable-latency and partition-prone networks that change over time. These types of clouds are interesting because they describe a much wider range of use cases than a data center environment, for example search and rescue clouds, mobile sensor clouds, or even transportation clouds. We believe that the unique challenges of this network environment require specialized consistency models in order to be effective. Because of the user-centric nature of this research, the requirement for collaboration and sharing, and in order to generalize distributed storage in this type of cloud we further propose the study of a file system as the primary data storage application. File systems must be highly available such that a user does not notice any delay due to coordination but must also have strong consistency such that any conflicts are presented to the user as soon as possible. These two requirements together provide a challenge for any single consistency model, particularly when the devices in the file system are mobile, can be turned off, and may have a variety of resource constraints.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="63854416c69280b0591eb58f88cf9fc1548ee8c0" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 133
, column: 206
)<div class="x"><button onclick="myFunction('63854416c69280b0591eb58f88cf9fc1548ee8c0');">X</button></div></td></tr>
<tr><th>Original</th><td>We propose to explore consistency mechanisms in \textit{user-centric dynamic clouds}: a multi-user tapestry of mobile, heterogenous devices connected via variable-latency and partition-prone networks that change over time. These types of clouds are interesting because they describe a much wider range of use cases than a data center environment, for example search and rescue clouds, mobile sensor clouds, or even transportation clouds. We believe that the unique challenges of this network environment require specialized consistency models in order to be effective. Because of the user-centric nature of this research, the requirement for collaboration and sharing, and in order to generalize distributed storage in this type of cloud we further propose the study of a file system as the primary data storage application. File systems must be highly available such that a user does not notice any delay due to coordination but must also have strong consistency such that any conflicts are presented to the user as soon as possible. These two requirements together provide a challenge for any single consistency model, particularly when the devices in the file system are mobile, can be turned off, and may have a variety of resource constraints.</td></tr>
<tr><th>Problem</th><td>change over time</td></tr>
<tr><th>Solution</th><td>phrase "change"
  </td></tr>
<tr><th>Trigger</th><td> 'change over time' in /Users/benjamin/.style-check.d/verbose-phrases:192</td></tr>
</table>
 phrase "change"
  (matched 'change over time' in /Users/benjamin/.style-check.d/verbose-phrases:192)
<table id="fd8744b293890f796c5f96e8f56a4bec72286167" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 136
, column: 181
)<div class="x"><button onclick="myFunction('fd8744b293890f796c5f96e8f56a4bec72286167');">X</button></div></td></tr>
<tr><th>Original</th><td>``environment''}. In a file system, the two primary symptoms of inconsistencies are version forks and stale reads. ``Weak'' (EC) systems depend on disseminating new writes quickly in order to prevent forks and stale reads. A ``strong'' (Raft consensus) system without caching might be provably correct, but might fail to make progress as network conditions deteriorate. Furthermore, file caching is essential to providing usable performance for any file system. Caching (without expensive validations) leads to stale reads. Forks can happen even without caching unless locking is used, however locks are too expensive for data center environments, much less user-centric dynamic clouds. Hence, a strong (Raft) system does not necessarily provide strong consistency guarantees on individual application-level file accesses. Further, the extent to which the system diverges from SC increases with decreasing network quality.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="e2ef45a6ac3baf663efb4015da434ca5517fb28a" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 136
, column: 833
)<div class="x"><button onclick="myFunction('e2ef45a6ac3baf663efb4015da434ca5517fb28a');">X</button></div></td></tr>
<tr><th>Original</th><td>``environment''}. In a file system, the two primary symptoms of inconsistencies are version forks and stale reads. ``Weak'' (EC) systems depend on disseminating new writes quickly in order to prevent forks and stale reads. A ``strong'' (Raft consensus) system without caching might be provably correct, but might fail to make progress as network conditions deteriorate. Furthermore, file caching is essential to providing usable performance for any file system. Caching (without expensive validations) leads to stale reads. Forks can happen even without caching unless locking is used, however locks are too expensive for data center environments, much less user-centric dynamic clouds. Hence, a strong (Raft) system does not necessarily provide strong consistency guarantees on individual application-level file accesses. Further, the extent to which the system diverges from SC increases with decreasing network quality.</td></tr>
<tr><th>Problem</th><td>the extent to which</td></tr>
<tr><th>Solution</th><td>phrase "how much"
  </td></tr>
<tr><th>Trigger</th><td> 'the extent to which' in /Users/benjamin/.style-check.d/verbose-phrases:137</td></tr>
</table>
 phrase "how much"
  (matched 'the extent to which' in /Users/benjamin/.style-check.d/verbose-phrases:137)
<table id="553ff7ae42ea3cadab14de9d9a27c9862c714203" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 141
, column: 1
)<div class="x"><button onclick="myFunction('553ff7ae42ea3cadab14de9d9a27c9862c714203');">X</button></div></td></tr>
<tr><th>Original</th><td>In order to provide any consistency guarantees in a dynamic environment the consistency model must be \textit{responsive}, providing flexibility when the network is unavailable or laggy and providing strong consistency guarantees when stable connections exist. Our approach focuses on two primary techniques to provide responsiveness: the \textit{federation} of weak but available consistency mechanisms with consensus implemented sequential consistency and the use of \textit{hierarchical} consensus to scale consensus groups beyond a handful of devices. ``Federated Consistency'' allows devices to switch local consistency models depending on the use case or to adapt consistency protocols automatically as the network environment changes, optimizing for strong consistency or availability as required. Availability in partition prone networks is provided by eventual consistency, and federation allows users to flexibly adapt to changing environments. ``Hierarchical Consensus'' increases the availability of a consensus group by creating decision localities of interest based on accesses to particular objects by a particular group of devices. Coordination with consensus is required for strong file system semantics and we propose that a hierarchical model makes consensus flexible enough for a file system. Both models are flexible locally, but can provide global system guarantees, guarantees we propose to explore in this research.</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="22b7c490f06dec3c54508fbb25a694dbf34f4676" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 143
, column: 274
)<div class="x"><button onclick="myFunction('22b7c490f06dec3c54508fbb25a694dbf34f4676');">X</button></div></td></tr>
<tr><th>Original</th><td>We hypothesize that the integration of multi-modal consistency with hierarchical centralized leadership via consensus will lead to higher availability than strong consistency models but provide stronger guarantees than eventually consistent systems. We will quantitatively demonstrate the efficacy of such a system through simulation and by implementing a file system, FlowFS, and testing it under real-life workloads. By comparing FlowFS to homogenous systems with similar sizes and topologies and measuring the number of inconsistencies and amount of latency in both simulation and a real world implementation we will show that responsive, flexible consistency protocols are more available and provide stronger guarantees than their homogenous counterparts in user-centric dynamic personal cloud topologies.</td></tr>
<tr><th>Problem</th><td>demonstrate</td></tr>
<tr><th>Solution</th><td>phrase show
  </td></tr>
<tr><th>Trigger</th><td> 'demonstrate' in /Users/benjamin/.style-check.d/barrass:10</td></tr>
</table>
 phrase show
  (matched 'demonstrate' in /Users/benjamin/.style-check.d/barrass:10)
<table id="26caca8d143498770ad61ea849812fcfbbb51d9c" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 143
, column: 4
)<div class="x"><button onclick="myFunction('26caca8d143498770ad61ea849812fcfbbb51d9c');">X</button></div></td></tr>
<tr><th>Original</th><td>We hypothesize that the integration of multi-modal consistency with hierarchical centralized leadership via consensus will lead to higher availability than strong consistency models but provide stronger guarantees than eventually consistent systems. We will quantitatively demonstrate the efficacy of such a system through simulation and by implementing a file system, FlowFS, and testing it under real-life workloads. By comparing FlowFS to homogenous systems with similar sizes and topologies and measuring the number of inconsistencies and amount of latency in both simulation and a real world implementation we will show that responsive, flexible consistency protocols are more available and provide stronger guarantees than their homogenous counterparts in user-centric dynamic personal cloud topologies.</td></tr>
<tr><th>Problem</th><td>hypothesize</td></tr>
<tr><th>Solution</th><td>phrase suggest
  </td></tr>
<tr><th>Trigger</th><td> 'hypothesize' in /Users/benjamin/.style-check.d/barrass:18</td></tr>
</table>
 phrase suggest
  (matched 'hypothesize' in /Users/benjamin/.style-check.d/barrass:18)
<table id="c6804c20bff064b7afd3f80b10103e8ec74a217b" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 150
, column: 123
)<div class="x"><button onclick="myFunction('c6804c20bff064b7afd3f80b10103e8ec74a217b');">X</button></div></td></tr>
<tr><th>Original</th><td>Our work is primarily grounded in data-centric consistency models. These models previously thought of as discrete levels, e.g. weak and strong, have more recently been viewed as a continuum ~. To provide background to consistency mechanisms in dynamic environments, we will start by defining a generalized log-based consistency model then extend it to our more file-system specific, primary metric: \textit{forks}. We will then explore various consistency levels on the consistency continuum: weak, eventual, causal, sequential, and linearizable expressed both in terms of the generalized model as well as how they perform in a file system context. This grounding primarily provides background to our first responsive approach: Federated Consistency.</td></tr>
<tr><th>Problem</th><td>e.g. </td></tr>
<tr><th>Solution</th><td>syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  </td></tr>
<tr><th>Trigger</th><td> 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33</td></tr>
</table>
 syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  (matched 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33)
<table id="67c1a4ebda52adc569892aab6959777893b9041d" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 150
, column: 562
)<div class="x"><button onclick="myFunction('67c1a4ebda52adc569892aab6959777893b9041d');">X</button></div></td></tr>
<tr><th>Original</th><td>Our work is primarily grounded in data-centric consistency models. These models previously thought of as discrete levels, e.g. weak and strong, have more recently been viewed as a continuum ~. To provide background to consistency mechanisms in dynamic environments, we will start by defining a generalized log-based consistency model then extend it to our more file-system specific, primary metric: \textit{forks}. We will then explore various consistency levels on the consistency continuum: weak, eventual, causal, sequential, and linearizable expressed both in terms of the generalized model as well as how they perform in a file system context. This grounding primarily provides background to our first responsive approach: Federated Consistency.</td></tr>
<tr><th>Problem</th><td>in terms of</td></tr>
<tr><th>Solution</th><td>phrase don't need this.
  </td></tr>
<tr><th>Trigger</th><td> 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136</td></tr>
</table>
 phrase don't need this.
  (matched 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136)
<table id="1ae22ae3717096dca6df591d4c37ed2b0033037a" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 150
, column: 616
)<div class="x"><button onclick="myFunction('1ae22ae3717096dca6df591d4c37ed2b0033037a');">X</button></div></td></tr>
<tr><th>Original</th><td>Our work is primarily grounded in data-centric consistency models. These models previously thought of as discrete levels, e.g. weak and strong, have more recently been viewed as a continuum ~. To provide background to consistency mechanisms in dynamic environments, we will start by defining a generalized log-based consistency model then extend it to our more file-system specific, primary metric: \textit{forks}. We will then explore various consistency levels on the consistency continuum: weak, eventual, causal, sequential, and linearizable expressed both in terms of the generalized model as well as how they perform in a file system context. This grounding primarily provides background to our first responsive approach: Federated Consistency.</td></tr>
<tr><th>Problem</th><td>perform</td></tr>
<tr><th>Solution</th><td>phrase "do"
  </td></tr>
<tr><th>Trigger</th><td> 'perform' in /Users/benjamin/.style-check.d/day-gastel:154</td></tr>
</table>
 phrase "do"
  (matched 'perform' in /Users/benjamin/.style-check.d/day-gastel:154)
<table id="4ad655c7682d18978b3cf26e532310d6c12425c3" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 152
, column: 279
)<div class="x"><button onclick="myFunction('4ad655c7682d18978b3cf26e532310d6c12425c3');">X</button></div></td></tr>
<tr><th>Original</th><td>Federated Consistency is a form of hybrid consistency where several consistency protocols are integrated in a single system. Because our preliminary work has focused on federation, we will present a detailed review of related work on hybridization and consistency rationing. We hypothesize that by integrating both eventual and sequential consistency such that there is a strong central core, similar to the architecture presented by Oceanstore ~, Federated Consistency will be able to provide stronger guarantees and centralized conflict resolution than other weaker consistency models, while providing flexibility and availability in variable latency environments.</td></tr>
<tr><th>Problem</th><td>hypothesize</td></tr>
<tr><th>Solution</th><td>phrase suggest
  </td></tr>
<tr><th>Trigger</th><td> 'hypothesize' in /Users/benjamin/.style-check.d/barrass:18</td></tr>
</table>
 phrase suggest
  (matched 'hypothesize' in /Users/benjamin/.style-check.d/barrass:18)
<table id="ebf3ebce0c2517a674647913165b49db0f099580" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 152
, column: 362
)<div class="x"><button onclick="myFunction('ebf3ebce0c2517a674647913165b49db0f099580');">X</button></div></td></tr>
<tr><th>Original</th><td>Federated Consistency is a form of hybrid consistency where several consistency protocols are integrated in a single system. Because our preliminary work has focused on federation, we will present a detailed review of related work on hybridization and consistency rationing. We hypothesize that by integrating both eventual and sequential consistency such that there is a strong central core, similar to the architecture presented by Oceanstore ~, Federated Consistency will be able to provide stronger guarantees and centralized conflict resolution than other weaker consistency models, while providing flexibility and availability in variable latency environments.</td></tr>
<tr><th>Problem</th><td>there is a strong central core, similar to the architecture presented by Oceanstore ~, Federated Consistency will be able to provide stronger guarantees and centralized conflict resolution than other weaker consistency models, while providing flexibility and availability in</td></tr>
<tr><th>Solution</th><td>phrase maybe this is passive
  </td></tr>
<tr><th>Trigger</th><td> 'there (are|is) [^\.:;]* (that|in)' in /Users/benjamin/.style-check.d/passive-voice:5</td></tr>
</table>
 phrase maybe this is passive
  (matched 'there (are|is) [^\.:;]* (that|in)' in /Users/benjamin/.style-check.d/passive-voice:5)
<table id="b2da71287f85f091c292dbbbdddc20a07ab2bf3b" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 154
, column: 512
)<div class="x"><button onclick="myFunction('b2da71287f85f091c292dbbbdddc20a07ab2bf3b');">X</button></div></td></tr>
<tr><th>Original</th><td>The strong central core must provide at least sequential consistency, a consistency level that is generally coordinated via a consensus protocol. Therefore, in the second part of the background, we will present consensus protocols, starting by a review of Paxos ~ and its various flavors. We have selected Raft ~ as our consensus protocol of choice, and therefore describe its operation in particular detail. Our review of consensus is intended to present the motivation and discussion of Hierarchical Consensus -- an extension of Raft that load balances the leader across decision spaces (groups of related objects) based on access patterns. Finally, in the last section of the background, we will review topics in replication that are critical to our work and present related systems already implemented.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax that's an en-dash, you want an em-dash: "---"
  </td></tr>
<tr><th>Trigger</th><td> '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24</td></tr>
</table>
 syntax that's an en-dash, you want an em-dash: "---"
  (matched '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24)
<table id="b2da71287f85f091c292dbbbdddc20a07ab2bf3b" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 154
, column: 512
)<div class="x"><button onclick="myFunction('b2da71287f85f091c292dbbbdddc20a07ab2bf3b');">X</button></div></td></tr>
<tr><th>Original</th><td>The strong central core must provide at least sequential consistency, a consistency level that is generally coordinated via a consensus protocol. Therefore, in the second part of the background, we will present consensus protocols, starting by a review of Paxos ~ and its various flavors. We have selected Raft ~ as our consensus protocol of choice, and therefore describe its operation in particular detail. Our review of consensus is intended to present the motivation and discussion of Hierarchical Consensus -- an extension of Raft that load balances the leader across decision spaces (groups of related objects) based on access patterns. Finally, in the last section of the background, we will review topics in replication that are critical to our work and present related systems already implemented.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax the en-dash should be between numbers.
  </td></tr>
<tr><th>Trigger</th><td> '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13</td></tr>
</table>
 syntax the en-dash should be between numbers.
  (matched '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13)
<table id="84686351dadb16343af4202ea9a005cfacdb53bd" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 161
, column: 655
)<div class="x"><button onclick="myFunction('84686351dadb16343af4202ea9a005cfacdb53bd');">X</button></div></td></tr>
<tr><th>Original</th><td>We can generalize data-centric consistency as follows: each replica is a state machine that applies commands in response to client requests or messages from other replicas. Each command is appended to a log that records the time ordered sequence of commands such that an entry at the end of the log happened before the previous entry. Replicas are locally consistent if they are in a similar state expressed by the relative condition of their logs (note that this generalization will translate well to a discussion of consensus in the next section); they are globally consistent if they are in a similar state to some abstract global ordering that meets one or more criteria. In either case, consistency guarantees can be described along two dimensions: staleness and ordering as follows:</td></tr>
<tr><th>Problem</th><td>one or more</td></tr>
<tr><th>Solution</th><td>phrase probably redundant -- nonzero is probably implied.
  </td></tr>
<tr><th>Trigger</th><td> 'one or more' in /Users/benjamin/.style-check.d/my-rules:26</td></tr>
</table>
 phrase probably redundant -- nonzero is probably implied.
  (matched 'one or more' in /Users/benjamin/.style-check.d/my-rules:26)
<table id="fee192ed4d9495b396c2d48f8f88b5869e2c296b" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 161
, column: 450
)<div class="x"><button onclick="myFunction('fee192ed4d9495b396c2d48f8f88b5869e2c296b');">X</button></div></td></tr>
<tr><th>Original</th><td>We can generalize data-centric consistency as follows: each replica is a state machine that applies commands in response to client requests or messages from other replicas. Each command is appended to a log that records the time ordered sequence of commands such that an entry at the end of the log happened before the previous entry. Replicas are locally consistent if they are in a similar state expressed by the relative condition of their logs (note that this generalization will translate well to a discussion of consensus in the next section); they are globally consistent if they are in a similar state to some abstract global ordering that meets one or more criteria. In either case, consistency guarantees can be described along two dimensions: staleness and ordering as follows:</td></tr>
<tr><th>Problem</th><td>note that</td></tr>
<tr><th>Solution</th><td>phrase is the rest of the paper less notable?
  </td></tr>
<tr><th>Trigger</th><td> 'note that' in /Users/benjamin/.style-check.d/verbose-phrases:29</td></tr>
</table>
 phrase is the rest of the paper less notable?
  (matched 'note that' in /Users/benjamin/.style-check.d/verbose-phrases:29)
<table id="9d4347e6941487cc4d8cc480d7adc1194d10aefc" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 164
, column: 193
)<div class="x"><button onclick="myFunction('9d4347e6941487cc4d8cc480d7adc1194d10aefc');">X</button></div></td></tr>
<tr><th>Original</th><td>    \item \textit{Staleness} refers to how far behind the latest global state a local log is and can be either expressed by the visibility latency of distributing a command to all replicas or simply by how many updates the log is behind by.</td></tr>
<tr><th>Problem</th><td>simply</td></tr>
<tr><th>Solution</th><td>phrase probably isn't.
  </td></tr>
<tr><th>Trigger</th><td> 'simply' in /Users/benjamin/.style-check.d/my-rules:51</td></tr>
</table>
 phrase probably isn't.
  (matched 'simply' in /Users/benjamin/.style-check.d/my-rules:51)
<table id="d2881504ed52e32d28f0f80dd4bc0004bec85152" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 168
, column: 661
)<div class="x"><button onclick="myFunction('d2881504ed52e32d28f0f80dd4bc0004bec85152');">X</button></div></td></tr>
<tr><th>Original</th><td>Most data-centric consistency models do not consider staleness but instead refer to the strictness of ordering guarantees and the method by which updates are applied to the state of the replica ~. This is primarily because enforcing ordering strictness leads to increased staleness. This occurs in two ways: increased coordination introduces delays between the issuance of a command and its local application and through dependencies that require dependent commands to be applied before the command in question. While staleness is easy to quantify in terms of time (t-visibility) and versions (k-staleness) ~, ordering is very difficult to quantify. Therefore in order to generalize to consistency models beyond eventual consistency, our model considers the specific symptoms of ordering inconsistency in a file system context: \textit{forks} and \textit{stale reads}.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="782ce1da3046c85cc44b2539dcfebfee150a68dd" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 168
, column: 549
)<div class="x"><button onclick="myFunction('782ce1da3046c85cc44b2539dcfebfee150a68dd');">X</button></div></td></tr>
<tr><th>Original</th><td>Most data-centric consistency models do not consider staleness but instead refer to the strictness of ordering guarantees and the method by which updates are applied to the state of the replica ~. This is primarily because enforcing ordering strictness leads to increased staleness. This occurs in two ways: increased coordination introduces delays between the issuance of a command and its local application and through dependencies that require dependent commands to be applied before the command in question. While staleness is easy to quantify in terms of time (t-visibility) and versions (k-staleness) ~, ordering is very difficult to quantify. Therefore in order to generalize to consistency models beyond eventual consistency, our model considers the specific symptoms of ordering inconsistency in a file system context: \textit{forks} and \textit{stale reads}.</td></tr>
<tr><th>Problem</th><td>in terms of</td></tr>
<tr><th>Solution</th><td>phrase don't need this.
  </td></tr>
<tr><th>Trigger</th><td> 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136</td></tr>
</table>
 phrase don't need this.
  (matched 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136)
<table id="1f227988d3bde6698f2d56c1e0e8fec1b9c48ed2" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 168
, column: 540
)<div class="x"><button onclick="myFunction('1f227988d3bde6698f2d56c1e0e8fec1b9c48ed2');">X</button></div></td></tr>
<tr><th>Original</th><td>Most data-centric consistency models do not consider staleness but instead refer to the strictness of ordering guarantees and the method by which updates are applied to the state of the replica ~. This is primarily because enforcing ordering strictness leads to increased staleness. This occurs in two ways: increased coordination introduces delays between the issuance of a command and its local application and through dependencies that require dependent commands to be applied before the command in question. While staleness is easy to quantify in terms of time (t-visibility) and versions (k-staleness) ~, ordering is very difficult to quantify. Therefore in order to generalize to consistency models beyond eventual consistency, our model considers the specific symptoms of ordering inconsistency in a file system context: \textit{forks} and \textit{stale reads}.</td></tr>
<tr><th>Problem</th><td>quantify</td></tr>
<tr><th>Solution</th><td>phrase "measure"
  </td></tr>
<tr><th>Trigger</th><td> 'quantify' in /Users/benjamin/.style-check.d/day-gastel:161</td></tr>
</table>
 phrase "measure"
  (matched 'quantify' in /Users/benjamin/.style-check.d/day-gastel:161)
<table id="1e1c7945dfd9fac065fcfe5625155cb97ba2d9b7" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 173
, column: 322
)<div class="x"><button onclick="myFunction('1e1c7945dfd9fac065fcfe5625155cb97ba2d9b7');">X</button></div></td></tr>
<tr><th>Original</th><td>We define a file system as a hierarchical namespace of object \textit{versions} where a version represents the immutable state of a particular object at a specific time ~. The \textit{view} of a file system is the set of locally cached versions, usually the latest version, for each object. Accesses to specific objects, e.g. read and write, update the local view of the file system and must be replicated in order for the file system to be consistent across replicas.</td></tr>
<tr><th>Problem</th><td>e.g. </td></tr>
<tr><th>Solution</th><td>syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  </td></tr>
<tr><th>Trigger</th><td> 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33</td></tr>
</table>
 syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  (matched 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33)
<table id="3c54b635d189440b85856a3db39bb802b061fe2e" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 173
, column: 43
)<div class="x"><button onclick="myFunction('3c54b635d189440b85856a3db39bb802b061fe2e');">X</button></div></td></tr>
<tr><th>Original</th><td>We define a file system as a hierarchical namespace of object \textit{versions} where a version represents the immutable state of a particular object at a specific time ~. The \textit{view} of a file system is the set of locally cached versions, usually the latest version, for each object. Accesses to specific objects, e.g. read and write, update the local view of the file system and must be replicated in order for the file system to be consistent across replicas.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="829569e4b37cc0192ab83734f739bc6b03d520b3" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 175
, column: 493
)<div class="x"><button onclick="myFunction('829569e4b37cc0192ab83734f739bc6b03d520b3');">X</button></div></td></tr>
<tr><th>Original</th><td>We propose a file-system specific consistency model that extends the generalized log ordering consistency method. In this model, commands are file accesses to a single object and each replica maintains a single, ordered log of accesses. Write accesses update the state of the file system (or view) by creating new versions of objects; read accesses update the state by determining the most recent version of the object either via the local cache or via a remote access. A \textit{stale read} is defined as a read to the local cache that returns a version of the object that is behind the latest global version. The ordering of reads and writes in the log determines the chronological sequence of all accesses to the file system and therefore defines the version history.</td></tr>
<tr><th>Problem</th><td>is defined as</td></tr>
<tr><th>Solution</th><td>phrase "is"
  </td></tr>
<tr><th>Trigger</th><td> 'is defined as' in /Users/benjamin/.style-check.d/day-gastel:108</td></tr>
</table>
 phrase "is"
  (matched 'is defined as' in /Users/benjamin/.style-check.d/day-gastel:108)
<table id="7785bbecf10734ab85d4442bac1bb55caff4464a" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 177
, column: 642
)<div class="x"><button onclick="myFunction('7785bbecf10734ab85d4442bac1bb55caff4464a');">X</button></div></td></tr>
<tr><th>Original</th><td>Each \textit{version} is a piece of meta data that describes an object state at a particular time and is identified by a monotonically increasing, conflict-free version number ~. Versions can contain dependency information, and in particular one dependency is required for all versions: the version of the parent upon whose access created the resulting version. An object's version history is therefore a tree, though the desired history is a single sequence or chain of unbroken updates to the object. Inconsistency in a file system is therefore a divergence in the linear history of the set of objects in the namespace and can be measured in terms of \textit{forks}.</td></tr>
<tr><th>Problem</th><td>in terms of</td></tr>
<tr><th>Solution</th><td>phrase don't need this.
  </td></tr>
<tr><th>Trigger</th><td> 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136</td></tr>
</table>
 phrase don't need this.
  (matched 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136)
<table id="29fbc8c211e21c63c936b9c9b3d544788c57cfd9" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 177
, column: 612
)<div class="x"><button onclick="myFunction('29fbc8c211e21c63c936b9c9b3d544788c57cfd9');">X</button></div></td></tr>
<tr><th>Original</th><td>Each \textit{version} is a piece of meta data that describes an object state at a particular time and is identified by a monotonically increasing, conflict-free version number ~. Versions can contain dependency information, and in particular one dependency is required for all versions: the version of the parent upon whose access created the resulting version. An object's version history is therefore a tree, though the desired history is a single sequence or chain of unbroken updates to the object. Inconsistency in a file system is therefore a divergence in the linear history of the set of objects in the namespace and can be measured in terms of \textit{forks}.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="f06a0e1eda63e0ce00286f54d38d667a5ad0b8f0" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 187
, column: 129
)<div class="x"><button onclick="myFunction('f06a0e1eda63e0ce00286f54d38d667a5ad0b8f0');">X</button></div></td></tr>
<tr><th>Original</th><td>    \item[\textbf{Fork}] A fork occurs when two replicas concurrently write a new version to the same parent object as shown in Figure \ref{fig:forks}. Forks introduce inconsistency because there are now two potential orderings of updates to the log, but forks are primarily the symptom of staleness; e.g. the second writer wrote to a stale version of the object.</td></tr>
<tr><th>Problem</th><td>Figure \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="48a035815fdfe04d68dcaee642f6fb3996c77d62" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 187
, column: 288
)<div class="x"><button onclick="myFunction('48a035815fdfe04d68dcaee642f6fb3996c77d62');">X</button></div></td></tr>
<tr><th>Original</th><td>    \item[\textbf{Fork}] A fork occurs when two replicas concurrently write a new version to the same parent object as shown in Figure ~. Forks introduce inconsistency because there are now two potential orderings of updates to the log, but forks are primarily the symptom of staleness; e.g. the second writer wrote to a stale version of the object.</td></tr>
<tr><th>Problem</th><td>e.g. </td></tr>
<tr><th>Solution</th><td>syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  </td></tr>
<tr><th>Trigger</th><td> 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33</td></tr>
</table>
 syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  (matched 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33)
<table id="c3950e57ab343f70337127157c7e41f042b36440" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 190
, column: 791
)<div class="x"><button onclick="myFunction('c3950e57ab343f70337127157c7e41f042b36440');">X</button></div></td></tr>
<tr><th>Original</th><td>There are two primary causes of forks: concurrent accesses by multiple replicas (a true conflict between multiple writers) and stale reads. The former is distinguished from the latter only if the possibility of synchronization (a process to bring replica logs to the same state) could have occurred. From the point of view of the system, they are identical causes. Forks can branch to arbitrary lengths as replicas continue to write to their latest local copies, however when synchronization occurs a decision as to which ordering of writes is correct must occur. Note that conflict in this consistency model refers to the concurrent access of the same or dependent objects. In fact, it is possible that the concurrent access to two independent objects causes two different, valid orderings -- however because it is difficult to implicitly define objects that are independent from each other, consistency definitions do not take this conflict into account.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax that's an en-dash, you want an em-dash: "---"
  </td></tr>
<tr><th>Trigger</th><td> '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24</td></tr>
</table>
 syntax that's an en-dash, you want an em-dash: "---"
  (matched '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24)
<table id="2e9e201e04098aef3d3c35195f2427db28de25a9" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 190
, column: 511
)<div class="x"><button onclick="myFunction('2e9e201e04098aef3d3c35195f2427db28de25a9');">X</button></div></td></tr>
<tr><th>Original</th><td>There are two primary causes of forks: concurrent accesses by multiple replicas (a true conflict between multiple writers) and stale reads. The former is distinguished from the latter only if the possibility of synchronization (a process to bring replica logs to the same state) could have occurred. From the point of view of the system, they are identical causes. Forks can branch to arbitrary lengths as replicas continue to write to their latest local copies, however when synchronization occurs a decision as to which ordering of writes is correct must occur. Note that conflict in this consistency model refers to the concurrent access of the same or dependent objects. In fact, it is possible that the concurrent access to two independent objects causes two different, valid orderings -- however because it is difficult to implicitly define objects that are independent from each other, consistency definitions do not take this conflict into account.</td></tr>
<tr><th>Problem</th><td>as to</td></tr>
<tr><th>Solution</th><td>phrase "about" or leave out
  </td></tr>
<tr><th>Trigger</th><td> 'as to' in /Users/benjamin/.style-check.d/day-gastel:24</td></tr>
</table>
 phrase "about" or leave out
  (matched 'as to' in /Users/benjamin/.style-check.d/day-gastel:24)
<table id="988d1d0df49a552ceb886ccde2b4e2b1283d8d15" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 190
, column: 301
)<div class="x"><button onclick="myFunction('988d1d0df49a552ceb886ccde2b4e2b1283d8d15');">X</button></div></td></tr>
<tr><th>Original</th><td>There are two primary causes of forks: concurrent accesses by multiple replicas (a true conflict between multiple writers) and stale reads. The former is distinguished from the latter only if the possibility of synchronization (a process to bring replica logs to the same state) could have occurred. From the point of view of the system, they are identical causes. Forks can branch to arbitrary lengths as replicas continue to write to their latest local copies, however when synchronization occurs a decision as to which ordering of writes is correct must occur. Note that conflict in this consistency model refers to the concurrent access of the same or dependent objects. In fact, it is possible that the concurrent access to two independent objects causes two different, valid orderings -- however because it is difficult to implicitly define objects that are independent from each other, consistency definitions do not take this conflict into account.</td></tr>
<tr><th>Problem</th><td>From the point of view of</td></tr>
<tr><th>Solution</th><td>phrase "for"
  </td></tr>
<tr><th>Trigger</th><td> 'from the point of view of' in /Users/benjamin/.style-check.d/day-gastel:65</td></tr>
</table>
 phrase "for"
  (matched 'from the point of view of' in /Users/benjamin/.style-check.d/day-gastel:65)
<table id="c3950e57ab343f70337127157c7e41f042b36440" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 190
, column: 791
)<div class="x"><button onclick="myFunction('c3950e57ab343f70337127157c7e41f042b36440');">X</button></div></td></tr>
<tr><th>Original</th><td>There are two primary causes of forks: concurrent accesses by multiple replicas (a true conflict between multiple writers) and stale reads. The former is distinguished from the latter only if the possibility of synchronization (a process to bring replica logs to the same state) could have occurred. From the point of view of the system, they are identical causes. Forks can branch to arbitrary lengths as replicas continue to write to their latest local copies, however when synchronization occurs a decision as to which ordering of writes is correct must occur. Note that conflict in this consistency model refers to the concurrent access of the same or dependent objects. In fact, it is possible that the concurrent access to two independent objects causes two different, valid orderings -- however because it is difficult to implicitly define objects that are independent from each other, consistency definitions do not take this conflict into account.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax the en-dash should be between numbers.
  </td></tr>
<tr><th>Trigger</th><td> '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13</td></tr>
</table>
 syntax the en-dash should be between numbers.
  (matched '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13)
<table id="d0882c7ab8c99b4ee4ea3697f802942d97a07ce4" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 190
, column: 610
)<div class="x"><button onclick="myFunction('d0882c7ab8c99b4ee4ea3697f802942d97a07ce4');">X</button></div></td></tr>
<tr><th>Original</th><td>There are two primary causes of forks: concurrent accesses by multiple replicas (a true conflict between multiple writers) and stale reads. The former is distinguished from the latter only if the possibility of synchronization (a process to bring replica logs to the same state) could have occurred. From the point of view of the system, they are identical causes. Forks can branch to arbitrary lengths as replicas continue to write to their latest local copies, however when synchronization occurs a decision as to which ordering of writes is correct must occur. Note that conflict in this consistency model refers to the concurrent access of the same or dependent objects. In fact, it is possible that the concurrent access to two independent objects causes two different, valid orderings -- however because it is difficult to implicitly define objects that are independent from each other, consistency definitions do not take this conflict into account.</td></tr>
<tr><th>Problem</th><td>refers to the</td></tr>
<tr><th>Solution</th><td>phrase you're being wimpy in the definition.  use "is"
  </td></tr>
<tr><th>Trigger</th><td> 'refers to the' in /Users/benjamin/.style-check.d/my-rules:46</td></tr>
</table>
 phrase you're being wimpy in the definition.  use "is"
  (matched 'refers to the' in /Users/benjamin/.style-check.d/my-rules:46)
<table id="2321440e91ded95ad291822399efbbbb853ae41a" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 190
, column: 685
)<div class="x"><button onclick="myFunction('2321440e91ded95ad291822399efbbbb853ae41a');">X</button></div></td></tr>
<tr><th>Original</th><td>There are two primary causes of forks: concurrent accesses by multiple replicas (a true conflict between multiple writers) and stale reads. The former is distinguished from the latter only if the possibility of synchronization (a process to bring replica logs to the same state) could have occurred. From the point of view of the system, they are identical causes. Forks can branch to arbitrary lengths as replicas continue to write to their latest local copies, however when synchronization occurs a decision as to which ordering of writes is correct must occur. Note that conflict in this consistency model refers to the concurrent access of the same or dependent objects. In fact, it is possible that the concurrent access to two independent objects causes two different, valid orderings -- however because it is difficult to implicitly define objects that are independent from each other, consistency definitions do not take this conflict into account.</td></tr>
<tr><th>Problem</th><td>it is possible that</td></tr>
<tr><th>Solution</th><td>phrase "x may y"
  </td></tr>
<tr><th>Trigger</th><td> 'it is possible that' in /Users/benjamin/.style-check.d/verbose-phrases:118</td></tr>
</table>
 phrase "x may y"
  (matched 'it is possible that' in /Users/benjamin/.style-check.d/verbose-phrases:118)
<table id="5ef58372930235b3407adf0a53d70ce1cb523eb0" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 190
, column: 565
)<div class="x"><button onclick="myFunction('5ef58372930235b3407adf0a53d70ce1cb523eb0');">X</button></div></td></tr>
<tr><th>Original</th><td>There are two primary causes of forks: concurrent accesses by multiple replicas (a true conflict between multiple writers) and stale reads. The former is distinguished from the latter only if the possibility of synchronization (a process to bring replica logs to the same state) could have occurred. From the point of view of the system, they are identical causes. Forks can branch to arbitrary lengths as replicas continue to write to their latest local copies, however when synchronization occurs a decision as to which ordering of writes is correct must occur. Note that conflict in this consistency model refers to the concurrent access of the same or dependent objects. In fact, it is possible that the concurrent access to two independent objects causes two different, valid orderings -- however because it is difficult to implicitly define objects that are independent from each other, consistency definitions do not take this conflict into account.</td></tr>
<tr><th>Problem</th><td>Note that</td></tr>
<tr><th>Solution</th><td>phrase is the rest of the paper less notable?
  </td></tr>
<tr><th>Trigger</th><td> 'note that' in /Users/benjamin/.style-check.d/verbose-phrases:29</td></tr>
</table>
 phrase is the rest of the paper less notable?
  (matched 'note that' in /Users/benjamin/.style-check.d/verbose-phrases:29)
<table id="793185a496a586f649b8542e17a271040fde883b" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 195
, column: 435
)<div class="x"><button onclick="myFunction('793185a496a586f649b8542e17a271040fde883b');">X</button></div></td></tr>
<tr><th>Original</th><td>In this section we will identify several discrete consistency levels in order of increasing strictness of the ordering of their logs as defined by the generalized log consistency model presented by Bermbach and Kuhlenkamp ~. The relationship between these consistency models indicates that there is a continuum of consistency based on the strictness of ordering. We will also note, where possible, the effect of the consistency model in terms of file-system specific consistency and forks.</td></tr>
<tr><th>Problem</th><td>in terms of</td></tr>
<tr><th>Solution</th><td>phrase don't need this.
  </td></tr>
<tr><th>Trigger</th><td> 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136</td></tr>
</table>
 phrase don't need this.
  (matched 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136)
<table id="8069db3a5707c2669645a0410141ebebcc3f7d6c" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 195
, column: 1
)<div class="x"><button onclick="myFunction('8069db3a5707c2669645a0410141ebebcc3f7d6c');">X</button></div></td></tr>
<tr><th>Original</th><td>In this section we will identify several discrete consistency levels in order of increasing strictness of the ordering of their logs as defined by the generalized log consistency model presented by Bermbach and Kuhlenkamp ~. The relationship between these consistency models indicates that there is a continuum of consistency based on the strictness of ordering. We will also note, where possible, the effect of the consistency model in terms of file-system specific consistency and forks.</td></tr>
<tr><th>Problem</th><td>In this section we</td></tr>
<tr><th>Solution</th><td>phrase "In this section, we", or "In this section, I"
  </td></tr>
<tr><th>Trigger</th><td> 'In this section (we|I)' in /Users/benjamin/.style-check.d/verbose-phrases:128</td></tr>
</table>
 phrase "In this section, we", or "In this section, I"
  (matched 'In this section (we|I)' in /Users/benjamin/.style-check.d/verbose-phrases:128)
<table id="7ed604c7756d4e0fabb5fb64e987ee94b9267fe8" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 198
, column: 411
)<div class="x"><button onclick="myFunction('7ed604c7756d4e0fabb5fb64e987ee94b9267fe8');">X</button></div></td></tr>
<tr><th>Original</th><td>A weakly consistent system makes no guarantees whatsoever about the relationship of local to remote writes and whether or not any given update will become visible ~. Weak consistency is often described as ``replicas might get lucky and become consistent'' and in fact a weakly consistent implementation may not have a synchronization protocol whatsoever ~. For this reason, we do not consider weak consistency in general except to identify it as a baseline.</td></tr>
<tr><th>Problem</th><td>in general</td></tr>
<tr><th>Solution</th><td>phrase unless matched with "in specific," this is usually useless; perhaps "overall"
  </td></tr>
<tr><th>Trigger</th><td> 'in general' in /Users/benjamin/.style-check.d/verbose-phrases:19</td></tr>
</table>
 phrase unless matched with "in specific," this is usually useless; perhaps "overall"
  (matched 'in general' in /Users/benjamin/.style-check.d/verbose-phrases:19)
<table id="52a01a83187483a337defdb2092b4651be2e2b59" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 200
, column: 292
)<div class="x"><button onclick="myFunction('52a01a83187483a337defdb2092b4651be2e2b59');">X</button></div></td></tr>
<tr><th>Original</th><td>\textit{Eventual consistency (EC)} is primarily concerned with the final state of all logs in the system given some period of quiescence that allows the system to converge. In this case, all replicas, no matter their log ordering, should have identical final versions for all objects in the namespace. This suggests that eventual consistency requires some \textit{anti-entropy} mechanism to propagate writes and a policy to handle convergence ~. Eventual consistency is very popular for NoSQL databases and hosted distributed storage services ~ because it allows an optimistic approach to consistency: conflicts are rare in most systems, if something does go wrong, conflict resolution is passed to the application layer. In practice, most applications can handle some inconsistency and moreover the small inconsistency windows due to low latencies in cloud data centers make such conflicts rare and short-lived enough to be worth the risk ~.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="ff2e319c8198535684ea7e258feec31c63678178" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 200
, column: 422
)<div class="x"><button onclick="myFunction('ff2e319c8198535684ea7e258feec31c63678178');">X</button></div></td></tr>
<tr><th>Original</th><td>\textit{Eventual consistency (EC)} is primarily concerned with the final state of all logs in the system given some period of quiescence that allows the system to converge. In this case, all replicas, no matter their log ordering, should have identical final versions for all objects in the namespace. This suggests that eventual consistency requires some \textit{anti-entropy} mechanism to propagate writes and a policy to handle convergence ~. Eventual consistency is very popular for NoSQL databases and hosted distributed storage services ~ because it allows an optimistic approach to consistency: conflicts are rare in most systems, if something does go wrong, conflict resolution is passed to the application layer. In practice, most applications can handle some inconsistency and moreover the small inconsistency windows due to low latencies in cloud data centers make such conflicts rare and short-lived enough to be worth the risk ~.</td></tr>
<tr><th>Problem</th><td>to handle</td></tr>
<tr><th>Solution</th><td>phrase use a more specific verb like address, treat, solve
  </td></tr>
<tr><th>Trigger</th><td> '(we|to) handle' in /Users/benjamin/.style-check.d/verbose-phrases:108</td></tr>
</table>
 phrase use a more specific verb like address, treat, solve
  (matched '(we|to) handle' in /Users/benjamin/.style-check.d/verbose-phrases:108)
<table id="c1342f921c4b8e80921ba35532c0e16e26a99b37" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 200
, column: 642
)<div class="x"><button onclick="myFunction('c1342f921c4b8e80921ba35532c0e16e26a99b37');">X</button></div></td></tr>
<tr><th>Original</th><td>\textit{Eventual consistency (EC)} is primarily concerned with the final state of all logs in the system given some period of quiescence that allows the system to converge. In this case, all replicas, no matter their log ordering, should have identical final versions for all objects in the namespace. This suggests that eventual consistency requires some \textit{anti-entropy} mechanism to propagate writes and a policy to handle convergence ~. Eventual consistency is very popular for NoSQL databases and hosted distributed storage services ~ because it allows an optimistic approach to consistency: conflicts are rare in most systems, if something does go wrong, conflict resolution is passed to the application layer. In practice, most applications can handle some inconsistency and moreover the small inconsistency windows due to low latencies in cloud data centers make such conflicts rare and short-lived enough to be worth the risk ~.</td></tr>
<tr><th>Problem</th><td>something</td></tr>
<tr><th>Solution</th><td>phrase could eliminate.
  </td></tr>
<tr><th>Trigger</th><td> 'something' in /Users/benjamin/.style-check.d/verbose-phrases:168</td></tr>
</table>
 phrase could eliminate.
  (matched 'something' in /Users/benjamin/.style-check.d/verbose-phrases:168)
<table id="7d730ce261fe1e4809a96aaf5ebe690aef07478a" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 202
, column: 889
)<div class="x"><button onclick="myFunction('7d730ce261fe1e4809a96aaf5ebe690aef07478a');">X</button></div></td></tr>
<tr><th>Original</th><td>Eventual consistency implemented by a \textit{last writer wins} policy simply accepts all writes so long as they are more recent than the latest local versions. Eventual reads and writes are always performed on local caches and are therefore highly available since they return a response to accesses immediately. Eventual consistency does allow forks to occur and moreover allows individual replica logs to have wholly different orderings so long as the last version for each object is in the same given no accesses have occurred for a long enough period of time. As a result, the latest version of an object may alternate between writes to competing forks (a fairly weak semantic) and in this case, it is up to the application to detect the inconsistency. However, EC logs do have one important property - for each object, every write in the log is ordered in a monotonically increasing fashion.</td></tr>
<tr><th>Problem</th><td>fashion</td></tr>
<tr><th>Solution</th><td>phrase hrm.
  </td></tr>
<tr><th>Trigger</th><td> 'fashion' in /Users/benjamin/.style-check.d/bad-words:5</td></tr>
</table>
 phrase hrm.
  (matched 'fashion' in /Users/benjamin/.style-check.d/bad-words:5)
<table id="43b3c2d394b13d53e4022be36f3525a2a576f570" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 202
, column: 805
)<div class="x"><button onclick="myFunction('43b3c2d394b13d53e4022be36f3525a2a576f570');">X</button></div></td></tr>
<tr><th>Original</th><td>Eventual consistency implemented by a \textit{last writer wins} policy simply accepts all writes so long as they are more recent than the latest local versions. Eventual reads and writes are always performed on local caches and are therefore highly available since they return a response to accesses immediately. Eventual consistency does allow forks to occur and moreover allows individual replica logs to have wholly different orderings so long as the last version for each object is in the same given no accesses have occurred for a long enough period of time. As a result, the latest version of an object may alternate between writes to competing forks (a fairly weak semantic) and in this case, it is up to the application to detect the inconsistency. However, EC logs do have one important property - for each object, every write in the log is ordered in a monotonically increasing fashion.</td></tr>
<tr><th>Problem</th><td> - </td></tr>
<tr><th>Solution</th><td>syntax a hyphen surrounded by space should probably be an emdash '---'
  </td></tr>
<tr><th>Trigger</th><td> '[ ]-[ ]' in /Users/benjamin/.style-check.d/common-typos:6</td></tr>
</table>
 syntax a hyphen surrounded by space should probably be an emdash '---'
  (matched '[ ]-[ ]' in /Users/benjamin/.style-check.d/common-typos:6)
<table id="5384324bda10218173c50a81ed54349e56672f37" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 202
, column: 72
)<div class="x"><button onclick="myFunction('5384324bda10218173c50a81ed54349e56672f37');">X</button></div></td></tr>
<tr><th>Original</th><td>Eventual consistency implemented by a \textit{last writer wins} policy simply accepts all writes so long as they are more recent than the latest local versions. Eventual reads and writes are always performed on local caches and are therefore highly available since they return a response to accesses immediately. Eventual consistency does allow forks to occur and moreover allows individual replica logs to have wholly different orderings so long as the last version for each object is in the same given no accesses have occurred for a long enough period of time. As a result, the latest version of an object may alternate between writes to competing forks (a fairly weak semantic) and in this case, it is up to the application to detect the inconsistency. However, EC logs do have one important property - for each object, every write in the log is ordered in a monotonically increasing fashion.</td></tr>
<tr><th>Problem</th><td>simply</td></tr>
<tr><th>Solution</th><td>phrase probably isn't.
  </td></tr>
<tr><th>Trigger</th><td> 'simply' in /Users/benjamin/.style-check.d/my-rules:51</td></tr>
</table>
 phrase probably isn't.
  (matched 'simply' in /Users/benjamin/.style-check.d/my-rules:51)
<table id="111341fe592b69a86e7029ee11ceb6ccc5bc3160" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 204
, column: 736
)<div class="x"><button onclick="myFunction('111341fe592b69a86e7029ee11ceb6ccc5bc3160');">X</button></div></td></tr>
<tr><th>Original</th><td>\textit{Causal Consistency (CC)} ensures that all writes which have causal relationships have those dependencies satisfied (inserted into the log) before the write can become visible ~. Therefore, even though a write might have been propagated to another replica server it cannot be read until all of its dependencies have also been propagated. Causal consistency can increase staleness particularly when implicit or potential causality creates large dependency graphs that must be resolved before writes can be applied ~. This can be managed by allowing the application to explicitly specify the dependencies for each write ~. Causal consistency is often referred to as the ``strongest form of consistency for highly available systems'', however CC does not require replica convergence ~ though with a few modifications including a convergence mechanism, it can easily be bolted on to an eventual system ~.</td></tr>
<tr><th>Problem</th><td>'',</td></tr>
<tr><th>Solution</th><td>syntax end quotes go outside punctuation like . and ,
  </td></tr>
<tr><th>Trigger</th><td> '''[\.,]' in /Users/benjamin/.style-check.d/common-typos:4</td></tr>
</table>
 syntax end quotes go outside punctuation like . and ,
  (matched '''[\.,]' in /Users/benjamin/.style-check.d/common-typos:4)
<table id="c7f1f95bbd7a6d99d2dbb9295d1baffa5de5ef3f" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 204
, column: 657
)<div class="x"><button onclick="myFunction('c7f1f95bbd7a6d99d2dbb9295d1baffa5de5ef3f');">X</button></div></td></tr>
<tr><th>Original</th><td>\textit{Causal Consistency (CC)} ensures that all writes which have causal relationships have those dependencies satisfied (inserted into the log) before the write can become visible ~. Therefore, even though a write might have been propagated to another replica server it cannot be read until all of its dependencies have also been propagated. Causal consistency can increase staleness particularly when implicit or potential causality creates large dependency graphs that must be resolved before writes can be applied ~. This can be managed by allowing the application to explicitly specify the dependencies for each write ~. Causal consistency is often referred to as the ``strongest form of consistency for highly available systems'', however CC does not require replica convergence ~ though with a few modifications including a convergence mechanism, it can easily be bolted on to an eventual system ~.</td></tr>
<tr><th>Problem</th><td>referred to as</td></tr>
<tr><th>Solution</th><td>phrase "called"
  </td></tr>
<tr><th>Trigger</th><td> 'referred to as' in /Users/benjamin/.style-check.d/day-gastel:166</td></tr>
</table>
 phrase "called"
  (matched 'referred to as' in /Users/benjamin/.style-check.d/day-gastel:166)
<table id="66f277ee9b41e296165240232c51c47e551a35af" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 206
, column: 491
)<div class="x"><button onclick="myFunction('66f277ee9b41e296165240232c51c47e551a35af');">X</button></div></td></tr>
<tr><th>Original</th><td>Eventual and causal consistency are both weak forms of consistency that are designed for high availability; that is they can respond to requests immediately from a local cache without coordination. Conflict detection and resolution are therefore critical processes asynchronous with the accesses that cause the conflict. These types of consistency are well suited for network environments that are partitioned or such that effective coordination is not available at the time of the access; e.g. for a user working on an airplane with no connectivity. The following strong consistency models, on the other hand, require coordination at the time of the access, detecting and eliminating conflict synchronously.</td></tr>
<tr><th>Problem</th><td>e.g. </td></tr>
<tr><th>Solution</th><td>syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  </td></tr>
<tr><th>Trigger</th><td> 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33</td></tr>
</table>
 syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  (matched 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33)
<table id="afbafdd130fa688265dc59418982709b70d0fde6" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 206
, column: 464
)<div class="x"><button onclick="myFunction('afbafdd130fa688265dc59418982709b70d0fde6');">X</button></div></td></tr>
<tr><th>Original</th><td>Eventual and causal consistency are both weak forms of consistency that are designed for high availability; that is they can respond to requests immediately from a local cache without coordination. Conflict detection and resolution are therefore critical processes asynchronous with the accesses that cause the conflict. These types of consistency are well suited for network environments that are partitioned or such that effective coordination is not available at the time of the access; e.g. for a user working on an airplane with no connectivity. The following strong consistency models, on the other hand, require coordination at the time of the access, detecting and eliminating conflict synchronously.</td></tr>
<tr><th>Problem</th><td>at the time</td></tr>
<tr><th>Solution</th><td>phrase very likely "when"
  </td></tr>
<tr><th>Trigger</th><td> 'at the time' in /Users/benjamin/.style-check.d/verbose-phrases:41</td></tr>
</table>
 phrase very likely "when"
  (matched 'at the time' in /Users/benjamin/.style-check.d/verbose-phrases:41)
<table id="b401237485f2e4a564cb29b140f5a20397ab9d5f" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 208
, column: 665
)<div class="x"><button onclick="myFunction('b401237485f2e4a564cb29b140f5a20397ab9d5f');">X</button></div></td></tr>
<tr><th>Original</th><td>\textit{Sequential consistency (SC)} is a strong consistency model that requires that all replicas have the exact same ordering of their logs, such that all writes by all clients are appended in the same exact order ~. Sequential consistency is not strict in that it does not make guarantees about staleness (or the ordering of reads) but does require that all writes become visible in the same order ~. Sequentially consistency is typically implemented with consensus algorithms such as Paxos ~ or Raft ~ that coordinate logs by defining a transitive, global ordering for all conflicts. Alternatively, sequential consistency and can be implemented with warranties -- time based assertions about a group of objects that must be met on all replicas before the assertions expired ~.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax that's an en-dash, you want an em-dash: "---"
  </td></tr>
<tr><th>Trigger</th><td> '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24</td></tr>
</table>
 syntax that's an en-dash, you want an em-dash: "---"
  (matched '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24)
<table id="b401237485f2e4a564cb29b140f5a20397ab9d5f" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 208
, column: 665
)<div class="x"><button onclick="myFunction('b401237485f2e4a564cb29b140f5a20397ab9d5f');">X</button></div></td></tr>
<tr><th>Original</th><td>\textit{Sequential consistency (SC)} is a strong consistency model that requires that all replicas have the exact same ordering of their logs, such that all writes by all clients are appended in the same exact order ~. Sequential consistency is not strict in that it does not make guarantees about staleness (or the ordering of reads) but does require that all writes become visible in the same order ~. Sequentially consistency is typically implemented with consensus algorithms such as Paxos ~ or Raft ~ that coordinate logs by defining a transitive, global ordering for all conflicts. Alternatively, sequential consistency and can be implemented with warranties -- time based assertions about a group of objects that must be met on all replicas before the assertions expired ~.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax the en-dash should be between numbers.
  </td></tr>
<tr><th>Trigger</th><td> '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13</td></tr>
</table>
 syntax the en-dash should be between numbers.
  (matched '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13)
<table id="8689af8fa8d3d386c22be4651d5ae35c24c8eeb0" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 210
, column: 657
)<div class="x"><button onclick="myFunction('8689af8fa8d3d386c22be4651d5ae35c24c8eeb0');">X</button></div></td></tr>
<tr><th>Original</th><td>\textit{Linearizability (LIN)} is the strongest form of consistency; not only must all write operations occur in sequence, but all operations including reads must be ordered chronologically ~. A consensus algorithm alone cannot implement linearizability and instead some distributed locking mechanism is required. For example a consensus algorithm can be adapted to instead of making decisions about the total ordering of conflicting writes, granting or releasing locks from requestors, however this opens up the potential for deadlock and extremely poor performance, defeating the purposes of replication in the first place! Data center environments that don't have to deal with issues of clock skew by using super precise atomic and GPS clocks can use precise time measurements to enable a distributed two phase commit protocol ~, however every replica is required to have such a time piece, which is not practical for heterogenous topologies.</td></tr>
<tr><th>Problem</th><td>don't</td></tr>
<tr><th>Solution</th><td>spelling do not or will not.
  </td></tr>
<tr><th>Trigger</th><td> '[dw]on't' in /Users/benjamin/.style-check.d/bad-words:6</td></tr>
</table>
 spelling do not or will not.
  (matched '[dw]on't' in /Users/benjamin/.style-check.d/bad-words:6)
<table id="e05c1730484c0c8066f64ddf270976dea6422cf4" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 210
, column: 255
)<div class="x"><button onclick="myFunction('e05c1730484c0c8066f64ddf270976dea6422cf4');">X</button></div></td></tr>
<tr><th>Original</th><td>\textit{Linearizability (LIN)} is the strongest form of consistency; not only must all write operations occur in sequence, but all operations including reads must be ordered chronologically ~. A consensus algorithm alone cannot implement linearizability and instead some distributed locking mechanism is required. For example a consensus algorithm can be adapted to instead of making decisions about the total ordering of conflicting writes, granting or releasing locks from requestors, however this opens up the potential for deadlock and extremely poor performance, defeating the purposes of replication in the first place! Data center environments that don't have to deal with issues of clock skew by using super precise atomic and GPS clocks can use precise time measurements to enable a distributed two phase commit protocol ~, however every replica is required to have such a time piece, which is not practical for heterogenous topologies.</td></tr>
<tr><th>Problem</th><td>and instead</td></tr>
<tr><th>Solution</th><td>phrase replace with but?
  </td></tr>
<tr><th>Trigger</th><td> 'and instead' in /Users/benjamin/.style-check.d/verbose-phrases:11</td></tr>
</table>
 phrase replace with but?
  (matched 'and instead' in /Users/benjamin/.style-check.d/verbose-phrases:11)
<table id="d3bf70abbe6346341b4fd0f88a850d3a144a4681" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 217
, column: 876
)<div class="x"><button onclick="myFunction('d3bf70abbe6346341b4fd0f88a850d3a144a4681');">X</button></div></td></tr>
<tr><th>Original</th><td>One of the earliest attempts to hybridize weak and strong consistency was a model for parallel programming on shared memory systems by Agrawal et al ~. This model allowed programmers to relax strong consistency in certain contexts with causal memory or pipelined random access in order to improve parallel performance of applications. Per-operation consistency was extended to distributed storage by the RedBlue consistency model of Li et al ~. Here, replication operations are broken down into small, commutative suboperations that are classified as red (must be executed in the same order on all replicas) or blue (execution order can vary from site to site), so long as the dependencies of each suboperation are maintained. The consistency model is therefore global, specified by the red/blue ordering and can be adapted by redefining the ratio of red to blue operations, e.g. all blue operations is an eventually consistent system and all red is sequential.</td></tr>
<tr><th>Problem</th><td>e.g. </td></tr>
<tr><th>Solution</th><td>syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  </td></tr>
<tr><th>Trigger</th><td> 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33</td></tr>
</table>
 syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  (matched 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33)
<table id="bbb82c73c9ec41d6eeff89c67ea1b70d8290729b" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 217
, column: 278
)<div class="x"><button onclick="myFunction('bbb82c73c9ec41d6eeff89c67ea1b70d8290729b');">X</button></div></td></tr>
<tr><th>Original</th><td>One of the earliest attempts to hybridize weak and strong consistency was a model for parallel programming on shared memory systems by Agrawal et al ~. This model allowed programmers to relax strong consistency in certain contexts with causal memory or pipelined random access in order to improve parallel performance of applications. Per-operation consistency was extended to distributed storage by the RedBlue consistency model of Li et al ~. Here, replication operations are broken down into small, commutative suboperations that are classified as red (must be executed in the same order on all replicas) or blue (execution order can vary from site to site), so long as the dependencies of each suboperation are maintained. The consistency model is therefore global, specified by the red/blue ordering and can be adapted by redefining the ratio of red to blue operations, e.g. all blue operations is an eventually consistent system and all red is sequential.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="e7c98fab6e2cc38fa27cf500b0044c76f288986d" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 219
, column: 257
)<div class="x"><button onclick="myFunction('e7c98fab6e2cc38fa27cf500b0044c76f288986d');">X</button></div></td></tr>
<tr><th>Original</th><td>The next level above per-operation consistency hybridization is called \textit{consistency rationing} wherein individual objects or groups of objects have different consistency levels applied to them to create a global quality of service guarantee. Kraska et al. ~ initially proposed consistency rationing be on a per-transaction basis by classifying objects in three tiers: eventual, adaptable, and linearizable. Objects in the first and last groups were automatically assigned transaction semantics that maintained that level of consistency; however objects assigned the adaptable categorization had their consistency policies switched at runtime based on a cost function that either minimized time or write costs depending on user preference. This allowed consistency in the adaptable tier to be flexible and responsive to usage.</td></tr>
<tr><th>Problem</th><td>et al. </td></tr>
<tr><th>Solution</th><td>syntax use the \etal{} command instead. (or write one to italicize)
  </td></tr>
<tr><th>Trigger</th><td> '\bet al\.[^}]' in /Users/benjamin/.style-check.d/my-rules:5</td></tr>
</table>
 syntax use the \etal{} command instead. (or write one to italicize)
  (matched '\bet al\.[^}]' in /Users/benjamin/.style-check.d/my-rules:5)
<table id="711974a49277334b4287428245c3bd97611800fa" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 221
, column: 13
)<div class="x"><button onclick="myFunction('711974a49277334b4287428245c3bd97611800fa');">X</button></div></td></tr>
<tr><th>Original</th><td>Chihoub et al. extended the idea of consistency rationing and proposed limiting the number of stale reads or the automatic minimization of some consistency cost metric by using reporting and consistency levels already established in existing databases ~. Here multiple consistency levels are being utilized, but only one consistency model is employed at any given time for all objects, relaxing or strengthening depending on observed costs. By utilizing all possible consistency semantics in the database, this model allows a greater spectrum of consistency guarantees that adapt at runtime.</td></tr>
<tr><th>Problem</th><td>l. e</td></tr>
<tr><th>Solution</th><td>syntax a period usually ends a sentence, and sentences should start with a capital; doesn't apply for i.e., 
  </td></tr>
<tr><th>Trigger</th><td> '[^egs]\. [a-z]' in /Users/benjamin/.style-check.d/common-typos:9</td></tr>
</table>
 syntax a period usually ends a sentence, and sentences should start with a capital; doesn't apply for i.e., 
  (matched '[^egs]\. [a-z]' in /Users/benjamin/.style-check.d/common-typos:9)
<table id="0ffbad652610e9fe6dff7b9666a6d61f7a96209c" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 221
, column: 9
)<div class="x"><button onclick="myFunction('0ffbad652610e9fe6dff7b9666a6d61f7a96209c');">X</button></div></td></tr>
<tr><th>Original</th><td>Chihoub et al. extended the idea of consistency rationing and proposed limiting the number of stale reads or the automatic minimization of some consistency cost metric by using reporting and consistency levels already established in existing databases ~. Here multiple consistency levels are being utilized, but only one consistency model is employed at any given time for all objects, relaxing or strengthening depending on observed costs. By utilizing all possible consistency semantics in the database, this model allows a greater spectrum of consistency guarantees that adapt at runtime.</td></tr>
<tr><th>Problem</th><td>et al. </td></tr>
<tr><th>Solution</th><td>syntax use the \etal{} command instead. (or write one to italicize)
  </td></tr>
<tr><th>Trigger</th><td> '\bet al\.[^}]' in /Users/benjamin/.style-check.d/my-rules:5</td></tr>
</table>
 syntax use the \etal{} command instead. (or write one to italicize)
  (matched '\bet al\.[^}]' in /Users/benjamin/.style-check.d/my-rules:5)
<table id="aec54d5c6eef4e2d106f838675d754e804538c54" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 223
, column: 806
)<div class="x"><button onclick="myFunction('aec54d5c6eef4e2d106f838675d754e804538c54');">X</button></div></td></tr>
<tr><th>Original</th><td>Al-Ekram and Holt ~ propose a middleware based scheme to allow multiple consistency models in a single distributed storage system. They identify a similar range of consistency models, but use a middleware layer to forward client requests to an available replica that maintains consistency at the lowest required criteria by the client. However, although their work can be extended to deploying several consistency models in one system, they still expect a homogenous consistency model that can be swapped out on demand as client requirements change. Additionally their view of the ordering of updates of a system is from one versioned state to another and they apply their consistency reasoning to the divergence of a local replica's state version and the global version. Similar to SUNDR, proposed by Li et al. ~, an inconsistency is a fork in the global ordering of reads and writes (a ``history fork''). Our consistency model instead considers object forks, a more granular level that allows concurrent access to different objects without conflict while still ensuring that no history forks can happen.</td></tr>
<tr><th>Problem</th><td>et al. </td></tr>
<tr><th>Solution</th><td>syntax use the \etal{} command instead. (or write one to italicize)
  </td></tr>
<tr><th>Trigger</th><td> '\bet al\.[^}]' in /Users/benjamin/.style-check.d/my-rules:5</td></tr>
</table>
 syntax use the \etal{} command instead. (or write one to italicize)
  (matched '\bet al\.[^}]' in /Users/benjamin/.style-check.d/my-rules:5)
<table id="0a774d009353eb0fda0ba7dfc7e319e00b00bd51" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 228
, column: 419
)<div class="x"><button onclick="myFunction('0a774d009353eb0fda0ba7dfc7e319e00b00bd51');">X</button></div></td></tr>
<tr><th>Original</th><td>Consensus algorithms are generalized as replicated state machines where a quorum of replicas must coordinate to decide on the application of a command that will change the local state of the replica ~. By keeping a log of all applied commands, consensus is fault-tolerant because an offline node that rejoins the quorum can replay the commands to return to the same state as the other replicas.   Moreover, so long as a majority of nodes are online, the quorum can be said to be available, in that it will respond to requests that access the state. Because accesses can be seen as commands modifying the visible state of the object namespace, and because the command log is identical to the consistency logs described in the last section, we can say that consensus algorithms can be used to provide strong consistency at the cost of multiple coordination messages per access.</td></tr>
<tr><th>Problem</th><td>a majority of</td></tr>
<tr><th>Solution</th><td>phrase "most", though 'a majority of' implies more than 50  </td></tr>
<tr><th>Trigger</th><td> 'a majority of' in /Users/benjamin/.style-check.d/day-gastel:6</td></tr>
</table>
 phrase "most", though 'a majority of' implies more than 50  (matched 'a majority of' in /Users/benjamin/.style-check.d/day-gastel:6)
<table id="e257b039112b3de0e87507d871f1a1a5b820f70c" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 228
, column: 421
)<div class="x"><button onclick="myFunction('e257b039112b3de0e87507d871f1a1a5b820f70c');">X</button></div></td></tr>
<tr><th>Original</th><td>Consensus algorithms are generalized as replicated state machines where a quorum of replicas must coordinate to decide on the application of a command that will change the local state of the replica ~. By keeping a log of all applied commands, consensus is fault-tolerant because an offline node that rejoins the quorum can replay the commands to return to the same state as the other replicas.   Moreover, so long as a majority of nodes are online, the quorum can be said to be available, in that it will respond to requests that access the state. Because accesses can be seen as commands modifying the visible state of the object namespace, and because the command log is identical to the consistency logs described in the last section, we can say that consensus algorithms can be used to provide strong consistency at the cost of multiple coordination messages per access.</td></tr>
<tr><th>Problem</th><td>majority of</td></tr>
<tr><th>Solution</th><td>phrase "most"
  </td></tr>
<tr><th>Trigger</th><td> 'majority of' in /Users/benjamin/.style-check.d/day-gastel:133</td></tr>
</table>
 phrase "most"
  (matched 'majority of' in /Users/benjamin/.style-check.d/day-gastel:133)
<table id="a68a09cc76785b322e03e5da455e3b93988da81f" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 228
, column: 633
)<div class="x"><button onclick="myFunction('a68a09cc76785b322e03e5da455e3b93988da81f');">X</button></div></td></tr>
<tr><th>Original</th><td>Consensus algorithms are generalized as replicated state machines where a quorum of replicas must coordinate to decide on the application of a command that will change the local state of the replica ~. By keeping a log of all applied commands, consensus is fault-tolerant because an offline node that rejoins the quorum can replay the commands to return to the same state as the other replicas.   Moreover, so long as a majority of nodes are online, the quorum can be said to be available, in that it will respond to requests that access the state. Because accesses can be seen as commands modifying the visible state of the object namespace, and because the command log is identical to the consistency logs described in the last section, we can say that consensus algorithms can be used to provide strong consistency at the cost of multiple coordination messages per access.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="105c59e73ff0b020ec82b769a770e95e09fb024e" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 230
, column: 505
)<div class="x"><button onclick="myFunction('105c59e73ff0b020ec82b769a770e95e09fb024e');">X</button></div></td></tr>
<tr><th>Original</th><td>Most consensus algorithms in the literature are variations of the Paxos algorithm ~, and more specifically the Fast Paxos implementation ~. Paxos proposes three phases to safely apply a command to the state machine: \textit{prepare}, \textit{propose}, and \textit{accept}. All phases are two stages, the first a vote and the second a broadcast of the results of the vote. In the prepare phase, a replica attempts to establish the master replica for a specific command by broadcasting a ballot number and getting majority agreement that the ballot (the entry at the log at that position) is owned by the master. The second phase broadcasts the value and receives a majority vote if that state can be successfully applied. The third phase accepts (commits) the result to the state machine. The primary variation, Fast Paxos, bundles multiple requests by reserving ballot numbers ahead of time to eliminate the \textit{prepare} phase (which is why most descriptions of Paxos generally identify only two phases). One way we can think of this is as the election of a primary leader in the quorum.</td></tr>
<tr><th>Problem</th><td>getting</td></tr>
<tr><th>Solution</th><td>phrase probably "receiving" or "querying"
  </td></tr>
<tr><th>Trigger</th><td> 'getting' in /Users/benjamin/.style-check.d/verbose-phrases:48</td></tr>
</table>
 phrase probably "receiving" or "querying"
  (matched 'getting' in /Users/benjamin/.style-check.d/verbose-phrases:48)
<table id="e4294c4b80291039f5b66a233cadb099d04982d2" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 239
, column: 448
)<div class="x"><button onclick="myFunction('e4294c4b80291039f5b66a233cadb099d04982d2');">X</button></div></td></tr>
<tr><th>Original</th><td>Every Raft node can be in one of three states: \textit{follower}, \textit{candidate}, and \textit{leader} and are initialized in the follower state. The system has two primary timing parameters: the election timeout and the heartbeat interval. When in follower and candidate mode, a timeout is randomly selected from the election timeout range, and if the timeout occurs the node will become a candidate and start an election to become leader. If a majority of nodes vote yes to that candidate then the node switches to the leader state and begins sending ~ messages at the rate of one at least every heartbeat interval. If a follower or a candidate receives a valid ~ message, it resets its election timeout by selecting a new random timeout from the election timeout range. The relationship between the heartbeat interval and the election timeout must be such that at least two heartbeats can arrive before the node switches to candidacy. The random selection of a timeout prevents thrashing if all nodes are started at the same time.</td></tr>
<tr><th>Problem</th><td>a majority of</td></tr>
<tr><th>Solution</th><td>phrase "most", though 'a majority of' implies more than 50  </td></tr>
<tr><th>Trigger</th><td> 'a majority of' in /Users/benjamin/.style-check.d/day-gastel:6</td></tr>
</table>
 phrase "most", though 'a majority of' implies more than 50  (matched 'a majority of' in /Users/benjamin/.style-check.d/day-gastel:6)
<table id="55cfcf41c813f8548dcf2001ae90feced4695668" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 239
, column: 450
)<div class="x"><button onclick="myFunction('55cfcf41c813f8548dcf2001ae90feced4695668');">X</button></div></td></tr>
<tr><th>Original</th><td>Every Raft node can be in one of three states: \textit{follower}, \textit{candidate}, and \textit{leader} and are initialized in the follower state. The system has two primary timing parameters: the election timeout and the heartbeat interval. When in follower and candidate mode, a timeout is randomly selected from the election timeout range, and if the timeout occurs the node will become a candidate and start an election to become leader. If a majority of nodes vote yes to that candidate then the node switches to the leader state and begins sending ~ messages at the rate of one at least every heartbeat interval. If a follower or a candidate receives a valid ~ message, it resets its election timeout by selecting a new random timeout from the election timeout range. The relationship between the heartbeat interval and the election timeout must be such that at least two heartbeats can arrive before the node switches to candidacy. The random selection of a timeout prevents thrashing if all nodes are started at the same time.</td></tr>
<tr><th>Problem</th><td>majority of</td></tr>
<tr><th>Solution</th><td>phrase "most"
  </td></tr>
<tr><th>Trigger</th><td> 'majority of' in /Users/benjamin/.style-check.d/day-gastel:133</td></tr>
</table>
 phrase "most"
  (matched 'majority of' in /Users/benjamin/.style-check.d/day-gastel:133)
<table id="6a67602182da20e05a3dbfa58cb1bd6e73813579" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 241
, column: 408
)<div class="x"><button onclick="myFunction('6a67602182da20e05a3dbfa58cb1bd6e73813579');">X</button></div></td></tr>
<tr><th>Original</th><td>Once elected leader, all accesses are forwarded to that node. Leaders maintain a term identification, a monotonically increasing global number. If a message comes in with a remote term higher than the local, then that node must switch to being a follower and update their local term. Accesses and their terms are sent to all followers in ~ messages. Followers compare their terms to the access term, and if a majority of followers accept the access, then the leader sends a commit message in the following ~ RPC message.</td></tr>
<tr><th>Problem</th><td>a majority of</td></tr>
<tr><th>Solution</th><td>phrase "most", though 'a majority of' implies more than 50  </td></tr>
<tr><th>Trigger</th><td> 'a majority of' in /Users/benjamin/.style-check.d/day-gastel:6</td></tr>
</table>
 phrase "most", though 'a majority of' implies more than 50  (matched 'a majority of' in /Users/benjamin/.style-check.d/day-gastel:6)
<table id="450e17ed20e5f8a6b21ebd7867f73a17e6bcca37" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 241
, column: 410
)<div class="x"><button onclick="myFunction('450e17ed20e5f8a6b21ebd7867f73a17e6bcca37');">X</button></div></td></tr>
<tr><th>Original</th><td>Once elected leader, all accesses are forwarded to that node. Leaders maintain a term identification, a monotonically increasing global number. If a message comes in with a remote term higher than the local, then that node must switch to being a follower and update their local term. Accesses and their terms are sent to all followers in ~ messages. Followers compare their terms to the access term, and if a majority of followers accept the access, then the leader sends a commit message in the following ~ RPC message.</td></tr>
<tr><th>Problem</th><td>majority of</td></tr>
<tr><th>Solution</th><td>phrase "most"
  </td></tr>
<tr><th>Trigger</th><td> 'majority of' in /Users/benjamin/.style-check.d/day-gastel:133</td></tr>
</table>
 phrase "most"
  (matched 'majority of' in /Users/benjamin/.style-check.d/day-gastel:133)
<table id="3ff56fc14c645a694b1859cbf8514a1616c960e6" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 249
, column: 508
)<div class="x"><button onclick="myFunction('3ff56fc14c645a694b1859cbf8514a1616c960e6');">X</button></div></td></tr>
<tr><th>Original</th><td>Consistency and consensus are generally separate issues from the actual replication of both metadata and data in a distributed storage system. In fact, consistency only requires the replication of \emph{metadata} because it is the metadata that defines the view or state of the system ~. In fact, given that data can be replicated as immutable chunks or blocks identified by a hash function, the problem of replicating data is one of service availability ~ or data locality ~ not one of locality. Therefore for the purposes of this research, we focus on the consistent replication of metadata.</td></tr>
<tr><th>Problem</th><td>for the purposes of</td></tr>
<tr><th>Solution</th><td>phrase "For"
  </td></tr>
<tr><th>Trigger</th><td> 'For the purposes of' in /Users/benjamin/.style-check.d/verbose-phrases:110</td></tr>
</table>
 phrase "For"
  (matched 'For the purposes of' in /Users/benjamin/.style-check.d/verbose-phrases:110)
<table id="363b95de060abbbdcdf024039e1fef7602969868" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 251
, column: 448
)<div class="x"><button onclick="myFunction('363b95de060abbbdcdf024039e1fef7602969868');">X</button></div></td></tr>
<tr><th>Original</th><td>We have explored two primary methods of replication in a distributed file system: gossip and broadcast protocols. As a rule, limiting the number of messages sent during replication is important as the number of messages is a good metric for resource usage and constraints such as available bandwidth or message processing capability. Gossip protocols are generally used as anti-entropy to disseminate information across the network in an epidemic fashion. Because gossip protocols use peer-to-peer connections, there are only as many messages per gossip interval as there are pairwise associations. Broadcast replication, on the other hand, can quickly overwhelm a system if all nodes are broadcasting a message to all other nodes, but is used well in centralized systems such as the Raft protocol where only a leader broadcasts and followers respond to the leader.</td></tr>
<tr><th>Problem</th><td>fashion</td></tr>
<tr><th>Solution</th><td>phrase hrm.
  </td></tr>
<tr><th>Trigger</th><td> 'fashion' in /Users/benjamin/.style-check.d/bad-words:5</td></tr>
</table>
 phrase hrm.
  (matched 'fashion' in /Users/benjamin/.style-check.d/bad-words:5)
<table id="3b62e6bf3327493fbaa145d1bf2fa7cb86891d4d" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 253
, column: 434
)<div class="x"><button onclick="myFunction('3b62e6bf3327493fbaa145d1bf2fa7cb86891d4d');">X</button></div></td></tr>
<tr><th>Original</th><td>Gossip protocols (often called rumor spreading) are a form of epidemic information spreading that do not require central coordination ~. On a routine interval, specified by the ~ timing parameter, a replica will randomly select one of the other replicas in the system and exchange information. Because all nodes are randomly selecting another node at every interval, information travels quickly through the network in an exponential fashion and provide high fault-tolerance and even automatic stabilization. Generally speaking there are two types of gossip: \textit{push} and \textit{pull}. Push methods simply forward all locally updated information to the remote node on the anti-entropy interval. Pull methods require two phases: a request for information after a certain period and the response from the remote node.</td></tr>
<tr><th>Problem</th><td>fashion</td></tr>
<tr><th>Solution</th><td>phrase hrm.
  </td></tr>
<tr><th>Trigger</th><td> 'fashion' in /Users/benjamin/.style-check.d/bad-words:5</td></tr>
</table>
 phrase hrm.
  (matched 'fashion' in /Users/benjamin/.style-check.d/bad-words:5)
<table id="cd61c26b35298c4d680f7adeb2795f16cccc3609" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 253
, column: 605
)<div class="x"><button onclick="myFunction('cd61c26b35298c4d680f7adeb2795f16cccc3609');">X</button></div></td></tr>
<tr><th>Original</th><td>Gossip protocols (often called rumor spreading) are a form of epidemic information spreading that do not require central coordination ~. On a routine interval, specified by the ~ timing parameter, a replica will randomly select one of the other replicas in the system and exchange information. Because all nodes are randomly selecting another node at every interval, information travels quickly through the network in an exponential fashion and provide high fault-tolerance and even automatic stabilization. Generally speaking there are two types of gossip: \textit{push} and \textit{pull}. Push methods simply forward all locally updated information to the remote node on the anti-entropy interval. Pull methods require two phases: a request for information after a certain period and the response from the remote node.</td></tr>
<tr><th>Problem</th><td>simply</td></tr>
<tr><th>Solution</th><td>phrase probably isn't.
  </td></tr>
<tr><th>Trigger</th><td> 'simply' in /Users/benjamin/.style-check.d/my-rules:51</td></tr>
</table>
 phrase probably isn't.
  (matched 'simply' in /Users/benjamin/.style-check.d/my-rules:51)
<table id="6573c39aade3f85e616ace3a97b6090453afdf8b" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 255
, column: 747
)<div class="x"><button onclick="myFunction('6573c39aade3f85e616ace3a97b6090453afdf8b');">X</button></div></td></tr>
<tr><th>Original</th><td>Several replication protocols have directly influenced or inspired our work. Bayou ~ is an eventually consistent system that implements anti-entropy as its replication mechanism and conflict resolution by some primary or trusted centralized server. SUNDR ~ is a secure file system that integrates local and cloud storage and detects inconsistencies by identifying forks, our primary inconsistency metric. The Ori File System ~ replicates file history and allows the merge and grafting of histories similar to Git trees. As a result branches and forks are also a big part of the Ori methodology as are complex data structures for grafting and dealing with conflict. Finally, the Stellar consensus protocol ~ provides federated byzantine agreement through the use of quorum slices.</td></tr>
<tr><th>Problem</th><td>through the use of</td></tr>
<tr><th>Solution</th><td>phrase "by" or "with"
  </td></tr>
<tr><th>Trigger</th><td> 'through the use of' in /Users/benjamin/.style-check.d/day-gastel:193</td></tr>
</table>
 phrase "by" or "with"
  (matched 'through the use of' in /Users/benjamin/.style-check.d/day-gastel:193)
<table id="bb17b48aa6b45899e71240c36d413403de317f85" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 260
, column: 389
)<div class="x"><button onclick="myFunction('bb17b48aa6b45899e71240c36d413403de317f85');">X</button></div></td></tr>
<tr><th>Original</th><td>We have begun our investigation into the relationship between network environment and consistency by building a discrete event simulator (DES) that allows us to easily characterize networks and consistency protocols. The simulator was implemented in Python using the SimPy simulation package, allowing for rapid prototyping and implementation of a variety of processes and flexibility to put together a series of experimental simulations. For our preliminary work, we have utilized the simulator to investigate \textit{Federated Consistency} and have made progress by obtaining experimental results. In this section, we will describe the simulator and the investigation that led to the core proposal of Federated Consistency and Hierarchical Consensus. In the proposed work section, we will explore Federated Consistency in greater detail.</td></tr>
<tr><th>Problem</th><td>put together</td></tr>
<tr><th>Solution</th><td>phrase long: "construct" "build" or "assemble"
  </td></tr>
<tr><th>Trigger</th><td> 'put together' in /Users/benjamin/.style-check.d/verbose-phrases:59</td></tr>
</table>
 phrase long: "construct" "build" or "assemble"
  (matched 'put together' in /Users/benjamin/.style-check.d/verbose-phrases:59)
<table id="cba4e51a664386ee953a6720e8a6766f5361aa56" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 262
, column: 832
)<div class="x"><button onclick="myFunction('cba4e51a664386ee953a6720e8a6766f5361aa56');">X</button></div></td></tr>
<tr><th>Original</th><td>The simulator has two primary components: workload generators and device processes. Workload generators act as clients (users) that issue read and write accesses to named objects and are generally associated with a single device process such that the access is associated with a local replica. Device processes represent, for the most part, replica servers that are connected to each other through a specific topology. Devices respond to accesses, generate replication messages, and respond to messages from other devices. The input to a simulator therefore is a topology that defines the devices, their specific properties and connections as well as a workload trace or set of parameters to generate random, realistic workloads. Experiments are conducted by running multiple simulations in parallel with different combinations of the above parameters.</td></tr>
<tr><th>Problem</th><td>the above</td></tr>
<tr><th>Solution</th><td>phrase horrible phrase that must be expunged.  you might use "these" instead, but best to make the sentence stand alone.
  </td></tr>
<tr><th>Trigger</th><td> 'the above' in /Users/benjamin/.style-check.d/my-rules:34</td></tr>
</table>
 phrase horrible phrase that must be expunged.  you might use "these" instead, but best to make the sentence stand alone.
  (matched 'the above' in /Users/benjamin/.style-check.d/my-rules:34)
<table id="03113566288401fdbc4b8f0e31451c1275a52a0e" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 278
, column: 548
)<div class="x"><button onclick="myFunction('03113566288401fdbc4b8f0e31451c1275a52a0e');">X</button></div></td></tr>
<tr><th>Original</th><td>The primary input to a simulation is the topology of devices and their connections. Topologies allow us to vary connectivity and to simulate a range of network environments, exploring the effect of a variety of consistency protocols in user-centric dynamic clouds. Our standard model of user-centric dynamic clouds is described by multiple wide-area locations with variable network connectivity between and within each location. We propose to investigate a fully connected topology of replica devices each assigned a geographic region as shown in Figure \ref{fig:topology}. Within each region, replica nodes enjoy stable, low-latency connections with their neighbors. However, across regions the latency is higher and the connections variable, meaning that out of order messages and delays are more common across the wide area than in the local area. This topology can be further generalized to tiers of locations as shown in Figure \ref{fig:tiers}, such that groups of nodes are grouped hierarchically in tiers of increasing latency and variability.</td></tr>
<tr><th>Problem</th><td>Figure \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="695079404301fceaeabe415f77dc8ddcdd460c17" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 280
, column: 539
)<div class="x"><button onclick="myFunction('695079404301fceaeabe415f77dc8ddcdd460c17');">X</button></div></td></tr>
<tr><th>Original</th><td>User-centric, dynamic networks are susceptible to routine partitions, events that cause replication messages to be delayed or dropped. We define two types of communication failure events in our topology: node failure and network partitions. \textit{Node failure} occurs when a single node is shut off or stops responding to messages. \textit{Network partitions} occur when it is not possible for messages to be sent or received from a single geographic region. In both cases, two conditions must be dealt with by the replication protocol in order to satisfy correctness criteria: resending lost messages and bringing nodes that are behind up to date. Introducing these events in our simulation is future work, but is necessary to a complete investigation of consistency in variable network environments.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="2c704c145694ca31d4fe30f342abdb926325f743" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 282
, column: 489
)<div class="x"><button onclick="myFunction('2c704c145694ca31d4fe30f342abdb926325f743');">X</button></div></td></tr>
<tr><th>Original</th><td>Because most research on gossip protocols and consensus algorithms specify small topologies of a size that provide a minimum level of fault tolerance, our initial questions related to the scalability of consistency protocols to topologies with increasing numbers of nodes. In order to explore these questions, we designed an experiment with 46 independent simulations: 23 differently sized topologies from 5 to 225 devices and two homogenous consistency protocols. This example serves to demonstrate the methodology behind our simulations as well as highlight a number of the tunable knobs that allow us to explore our proposal in greater detail.</td></tr>
<tr><th>Problem</th><td>demonstrate</td></tr>
<tr><th>Solution</th><td>phrase show
  </td></tr>
<tr><th>Trigger</th><td> 'demonstrate' in /Users/benjamin/.style-check.d/barrass:10</td></tr>
</table>
 phrase show
  (matched 'demonstrate' in /Users/benjamin/.style-check.d/barrass:10)
<table id="5879ded2535bd35ac93b2fcc0d39ca9f85e7c50c" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 282
, column: 561
)<div class="x"><button onclick="myFunction('5879ded2535bd35ac93b2fcc0d39ca9f85e7c50c');">X</button></div></td></tr>
<tr><th>Original</th><td>Because most research on gossip protocols and consensus algorithms specify small topologies of a size that provide a minimum level of fault tolerance, our initial questions related to the scalability of consistency protocols to topologies with increasing numbers of nodes. In order to explore these questions, we designed an experiment with 46 independent simulations: 23 differently sized topologies from 5 to 225 devices and two homogenous consistency protocols. This example serves to demonstrate the methodology behind our simulations as well as highlight a number of the tunable knobs that allow us to explore our proposal in greater detail.</td></tr>
<tr><th>Problem</th><td>a number of</td></tr>
<tr><th>Solution</th><td>phrase getting the verb agreement for this useless phrase is tricky.
  </td></tr>
<tr><th>Trigger</th><td> 'a number of' in /Users/benjamin/.style-check.d/verbose-phrases:5</td></tr>
</table>
 phrase getting the verb agreement for this useless phrase is tricky.
  (matched 'a number of' in /Users/benjamin/.style-check.d/verbose-phrases:5)
<table id="ecc29cb2084f0c9d200c19c0a1e06dc710a3a9ad" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 282
, column: 274
)<div class="x"><button onclick="myFunction('ecc29cb2084f0c9d200c19c0a1e06dc710a3a9ad');">X</button></div></td></tr>
<tr><th>Original</th><td>Because most research on gossip protocols and consensus algorithms specify small topologies of a size that provide a minimum level of fault tolerance, our initial questions related to the scalability of consistency protocols to topologies with increasing numbers of nodes. In order to explore these questions, we designed an experiment with 46 independent simulations: 23 differently sized topologies from 5 to 225 devices and two homogenous consistency protocols. This example serves to demonstrate the methodology behind our simulations as well as highlight a number of the tunable knobs that allow us to explore our proposal in greater detail.</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="0126bc9e16c02c5ae45dc92c6a5f018f48fbaf3b" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 286
, column: 123
)<div class="x"><button onclick="myFunction('0126bc9e16c02c5ae45dc92c6a5f018f48fbaf3b');">X</button></div></td></tr>
<tr><th>Original</th><td>Both EC and SC implementations rely on timing parameters for messaging such as the gossip interval and election timeouts. In order to define a relationship between consistency models, these timing parameters are defined by network latency. We first computed a conservative ``tick'' parameter given as~. These conservative timing parameters ensure that it is rare that messages arrive out of order, even in highly variable connections.</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="7070fb2066eea84af67775155972e8cca6571125" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 288
, column: 200
)<div class="x"><button onclick="myFunction('7070fb2066eea84af67775155972e8cca6571125');">X</button></div></td></tr>
<tr><th>Original</th><td>The simulation workload was defined as a static trace of accesses such that all simulations received the same exact accesses. Each device implemented a workload of read and write accesses on a local namespace of 15 objects. Conflicts were introduced to the simulation by overlapping a subset of the local namespace of each device with the other device namespaces, specified by a probability of conflict,~ms such that accesses were roughly related to the timing parameters.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="2e955ddea689e293a9f48942d8ba6f20dba643c2" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 318
, column: 217
)<div class="x"><button onclick="myFunction('2e955ddea689e293a9f48942d8ba6f20dba643c2');">X</button></div></td></tr>
<tr><th>Original</th><td>As the number of nodes increases, the number of conflicts also increases -- but not the likelihood of a conflict. Our system primarily measures inconsistencies as \textit{forks} and \textit{stale reads}. As shown in Figure \ref{fig:scaling_forked_writes}, the number of conflicts that create forks in Raft is lower than in eventual. This is because eventual consistency relies on fast propagation of updates to minimize forks, which becomes increasingly slow for larger topologies; however Raft does eventually catch up to eventual when the number of nodes causing conflict is too much even for broadcast style distribution. In terms of stale reads, eventual consistency initially outperforms Raft for smaller topologies as shown in Figure \ref{fig:scaling_stale_reads}. There is a cross-over point where anti-entropy is faster at distribution then the broadcast mechanism takes over; this point is defined by the relationship of the anti-entropy interval with the heartbeat interval.</td></tr>
<tr><th>Problem</th><td>Figure \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="d8806393ce3e14f472120e716729941fd289a1ce" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 318
, column: 73
)<div class="x"><button onclick="myFunction('d8806393ce3e14f472120e716729941fd289a1ce');">X</button></div></td></tr>
<tr><th>Original</th><td>As the number of nodes increases, the number of conflicts also increases -- but not the likelihood of a conflict. Our system primarily measures inconsistencies as \textit{forks} and \textit{stale reads}. As shown in Figure ~, the number of conflicts that create forks in Raft is lower than in eventual. This is because eventual consistency relies on fast propagation of updates to minimize forks, which becomes increasingly slow for larger topologies; however Raft does eventually catch up to eventual when the number of nodes causing conflict is too much even for broadcast style distribution. In terms of stale reads, eventual consistency initially outperforms Raft for smaller topologies as shown in Figure ~. There is a cross-over point where anti-entropy is faster at distribution then the broadcast mechanism takes over; this point is defined by the relationship of the anti-entropy interval with the heartbeat interval.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax that's an en-dash, you want an em-dash: "---"
  </td></tr>
<tr><th>Trigger</th><td> '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24</td></tr>
</table>
 syntax that's an en-dash, you want an em-dash: "---"
  (matched '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24)
<table id="492de09159965430df715206d07cc51c3f4ed292" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 318
, column: 596
)<div class="x"><button onclick="myFunction('492de09159965430df715206d07cc51c3f4ed292');">X</button></div></td></tr>
<tr><th>Original</th><td>As the number of nodes increases, the number of conflicts also increases -- but not the likelihood of a conflict. Our system primarily measures inconsistencies as \textit{forks} and \textit{stale reads}. As shown in Figure ~, the number of conflicts that create forks in Raft is lower than in eventual. This is because eventual consistency relies on fast propagation of updates to minimize forks, which becomes increasingly slow for larger topologies; however Raft does eventually catch up to eventual when the number of nodes causing conflict is too much even for broadcast style distribution. In terms of stale reads, eventual consistency initially outperforms Raft for smaller topologies as shown in Figure ~. There is a cross-over point where anti-entropy is faster at distribution then the broadcast mechanism takes over; this point is defined by the relationship of the anti-entropy interval with the heartbeat interval.</td></tr>
<tr><th>Problem</th><td>In terms of</td></tr>
<tr><th>Solution</th><td>phrase don't need this.
  </td></tr>
<tr><th>Trigger</th><td> 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136</td></tr>
</table>
 phrase don't need this.
  (matched 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136)
<table id="d8806393ce3e14f472120e716729941fd289a1ce" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 318
, column: 73
)<div class="x"><button onclick="myFunction('d8806393ce3e14f472120e716729941fd289a1ce');">X</button></div></td></tr>
<tr><th>Original</th><td>As the number of nodes increases, the number of conflicts also increases -- but not the likelihood of a conflict. Our system primarily measures inconsistencies as \textit{forks} and \textit{stale reads}. As shown in Figure ~, the number of conflicts that create forks in Raft is lower than in eventual. This is because eventual consistency relies on fast propagation of updates to minimize forks, which becomes increasingly slow for larger topologies; however Raft does eventually catch up to eventual when the number of nodes causing conflict is too much even for broadcast style distribution. In terms of stale reads, eventual consistency initially outperforms Raft for smaller topologies as shown in Figure ~. There is a cross-over point where anti-entropy is faster at distribution then the broadcast mechanism takes over; this point is defined by the relationship of the anti-entropy interval with the heartbeat interval.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax the en-dash should be between numbers.
  </td></tr>
<tr><th>Trigger</th><td> '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13</td></tr>
</table>
 syntax the en-dash should be between numbers.
  (matched '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13)
<table id="870d006a3023f1e23eedd831034e9184dce39220" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 320
, column: 274
)<div class="x"><button onclick="myFunction('870d006a3023f1e23eedd831034e9184dce39220');">X</button></div></td></tr>
<tr><th>Original</th><td>Both of types of inconsistencies are directly related to how updates become fully visible in either system. In fact as the number of nodes increases, both systems start to degrade in the percent of writes that become fully visible, though EC far more than raft as shown in Figure \ref{fig:scaling_visible_writes}. For Eventual, this is because the time to visibility is related to the number of pairwise anti-entropy sessions required to propagate a write to all nodes as shown in Figure \ref{fig:scaling_visibility_latency}, where the red line represents perfect convergence (not likely given uniform random neighbor selection). If an update becomes outdated before it can become fully replicated, it gets ``stomped'', meaning that the later update is propagated over the earlier one. Raft on the other hand only stops writes from becoming fully visible if they are forks, dropping them and rejecting the access to the client who must retry.</td></tr>
<tr><th>Problem</th><td>Figure \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="9084462ec16a9e4462fe0a9715ab81bc4499704c" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 320
, column: 651
)<div class="x"><button onclick="myFunction('9084462ec16a9e4462fe0a9715ab81bc4499704c');">X</button></div></td></tr>
<tr><th>Original</th><td>Both of types of inconsistencies are directly related to how updates become fully visible in either system. In fact as the number of nodes increases, both systems start to degrade in the percent of writes that become fully visible, though EC far more than raft as shown in Figure ~. For Eventual, this is because the time to visibility is related to the number of pairwise anti-entropy sessions required to propagate a write to all nodes as shown in Figure ~, where the red line represents perfect convergence (not likely given uniform random neighbor selection). If an update becomes outdated before it can become fully replicated, it gets ``stomped'', meaning that the later update is propagated over the earlier one. Raft on the other hand only stops writes from becoming fully visible if they are forks, dropping them and rejecting the access to the client who must retry.</td></tr>
<tr><th>Problem</th><td>'',</td></tr>
<tr><th>Solution</th><td>syntax end quotes go outside punctuation like . and ,
  </td></tr>
<tr><th>Trigger</th><td> '''[\.,]' in /Users/benjamin/.style-check.d/common-typos:4</td></tr>
</table>
 syntax end quotes go outside punctuation like . and ,
  (matched '''[\.,]' in /Users/benjamin/.style-check.d/common-typos:4)
<table id="8474a80dc26b37fae5d4cfb97851682cf2e85c20" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 322
, column: 220
)<div class="x"><button onclick="myFunction('8474a80dc26b37fae5d4cfb97851682cf2e85c20');">X</button></div></td></tr>
<tr><th>Original</th><td>These figures seem to suggest that Raft is a much better replication protocol and that there doesn't seem to be any reason to use eventual consistency. However, eventual consistency allows more inconsistencies to occur in order to provide more flexibility and availability. Raft suffers from write and commit latencies and a bottleneck as all communication must pass through the leader. EC always accesses locally and therefore has no write latency. Raft also suffers from partitions and node failure, and cannot make progress if no leader exists; EC will always respond no matter the current network condition. Moreover, in these simulations, we have artificially constrained the anti-entropy rate by relating it to the ``tick'' parameter. As such, both protocols send approximately the same number of messages. However, without message limits, exponential anti-entropy can converge more quickly than Raft broadcast propagation, which must be sequential.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="66ae25121a675a5e71f51e2194b15d371e497304" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 322
, column: 94
)<div class="x"><button onclick="myFunction('66ae25121a675a5e71f51e2194b15d371e497304');">X</button></div></td></tr>
<tr><th>Original</th><td>These figures seem to suggest that Raft is a much better replication protocol and that there doesn't seem to be any reason to use eventual consistency. However, eventual consistency allows more inconsistencies to occur in order to provide more flexibility and availability. Raft suffers from write and commit latencies and a bottleneck as all communication must pass through the leader. EC always accesses locally and therefore has no write latency. Raft also suffers from partitions and node failure, and cannot make progress if no leader exists; EC will always respond no matter the current network condition. Moreover, in these simulations, we have artificially constrained the anti-entropy rate by relating it to the ``tick'' parameter. As such, both protocols send approximately the same number of messages. However, without message limits, exponential anti-entropy can converge more quickly than Raft broadcast propagation, which must be sequential.</td></tr>
<tr><th>Problem</th><td>doesn't</td></tr>
<tr><th>Solution</th><td>phrase be formal.
  </td></tr>
<tr><th>Trigger</th><td> 'doesn't' in /Users/benjamin/.style-check.d/my-rules:23</td></tr>
</table>
 phrase be formal.
  (matched 'doesn't' in /Users/benjamin/.style-check.d/my-rules:23)
<table id="8a5b3db50349920baf783f5e8a338572c0d3c193" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 324
, column: 154
)<div class="x"><button onclick="myFunction('8a5b3db50349920baf783f5e8a338572c0d3c193');">X</button></div></td></tr>
<tr><th>Original</th><td>We believe that these initial investigations show a critical opportunity: that we can blend the high availability of an eventually consistent system and leverage the best parts of anti-entropy and eventual consistency in network environments where messages cannot get through along with the stability and increased visibility of a strongly consistent core, similar to the central core and flexible outer shell proposed by Gray and Oceanstore ~: we call this \textit{Federated Consistency}. Furthermore, if we can find a way to allocate decision space to a smaller number of nodes, we should be able to scale Raft to greater number of nodes without as steep a curve: we investigate this in \textit{Hierarchical Consensus}. Finally, as suggested by the~ ``tick'' parameter (though not explicitly covered), the timing measures and performance of consistency protocols are related to the network environment, which is dynamic. Potentially we can improve performance by monitoring the environment and adapting timing parameters to minimize the number of inconsistencies: investigated in \textit{Adaptive Consistency}.</td></tr>
<tr><th>Problem</th><td>leverage</td></tr>
<tr><th>Solution</th><td>phrase "use"
  </td></tr>
<tr><th>Trigger</th><td> 'leverage' in /Users/benjamin/.style-check.d/bad-words:3</td></tr>
</table>
 phrase "use"
  (matched 'leverage' in /Users/benjamin/.style-check.d/bad-words:3)
<table id="ffee8b989d50addad62fc903121a5af8153759e2" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 329
, column: 172
)<div class="x"><button onclick="myFunction('ffee8b989d50addad62fc903121a5af8153759e2');">X</button></div></td></tr>
<tr><th>Original</th><td>We propose two mechanisms that together will provide responsive, flexible consistency in user-centric dynamic clouds: Federated Consistency and Hierarchical consensus. We hypothesize that the integration of federated consistency models and scalable consensus through these two methodologies will lead to a system that is quantitatively more available (experiences lower aggregate read, write, commit, and visibility latencies) than a homogenous implementation of a sequentially consistent system implemented by Raft. Further we hypothesize that such a system will have stronger consistency guarantees (fewer forks and stale reads) than a homogenous implementation of an eventually consistent file system implemented with bilateral gossip anti-entropy.</td></tr>
<tr><th>Problem</th><td>hypothesize</td></tr>
<tr><th>Solution</th><td>phrase suggest
  </td></tr>
<tr><th>Trigger</th><td> 'hypothesize' in /Users/benjamin/.style-check.d/barrass:18</td></tr>
</table>
 phrase suggest
  (matched 'hypothesize' in /Users/benjamin/.style-check.d/barrass:18)
<table id="61fa6c9adadb00fdfe0241d2e2b218dab3cb7bda" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 331
, column: 793
)<div class="x"><button onclick="myFunction('61fa6c9adadb00fdfe0241d2e2b218dab3cb7bda');">X</button></div></td></tr>
<tr><th>Original</th><td>Federated Consistency and Hierarchical Consensus provide different opportunities to scale and handle variable environments, each enhancing the other. Federated Consistency allows us to create a flexible, heterogenous distributed system, allowing different replica servers to maintain different consistency levels based on need, but ensuring that global consistency guarantees are met. Hierarchical Consensus extends the Raft consensus protocol to use consensus partitioning as a means of achieving scale and high availability among replicated logs, without sacrificing sequential consistency. We hope to further stretch our proposal to include the investigation of real time optimization and adaptation in response to changing environments. The stretch goal, Adaptive Consistency proposes to utilize both heuristic methods of steering configuration change as well as active, machine learning mechanisms for online optimization.</td></tr>
<tr><th>Problem</th><td>utilize</td></tr>
<tr><th>Solution</th><td>phrase "use"
  </td></tr>
<tr><th>Trigger</th><td> 'utilize' in /Users/benjamin/.style-check.d/day-gastel:200</td></tr>
</table>
 phrase "use"
  (matched 'utilize' in /Users/benjamin/.style-check.d/day-gastel:200)
<table id="d8fe47f3796731e92503761312148254abcb48d3" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 333
, column: 580
)<div class="x"><button onclick="myFunction('d8fe47f3796731e92503761312148254abcb48d3');">X</button></div></td></tr>
<tr><th>Original</th><td>We propose to confirm our hypotheses in two ways: through the simulation of a variety of network environments and conditions and through real world experimentation on a fully implemented system. The simulation, as discussed in the preliminary work section will allow us to easily explore a variety of environments at a low cost of time and effort. We propose to extend our preliminary work to account for outages and to provide visualizations of consistency protocols. The full implementation will be a distributed file system called \emph{FlowFS} whose architecture is given in Figure \ref{fig:architecture}. By exploring real world workloads in real network environments we will be able to make constructive claims about how consistency needs to evolve as user-centric dynamic clouds become increasingly important.</td></tr>
<tr><th>Problem</th><td>Figure \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="9329be666ca222b41a9054cd7b6d49fc7dd2fc4f" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 340
, column: 737
)<div class="x"><button onclick="myFunction('9329be666ca222b41a9054cd7b6d49fc7dd2fc4f');">X</button></div></td></tr>
<tr><th>Original</th><td>Heterogenous topologies with multiple users mean a variety of requirements for both availability and correctness. For example, consider a user working on a non-critical document on a train with limited cellular connectivity; the requirement here is probably high availability and progress rather than strong replication. On the other hand, during collaborative document editing, users might want to ensure strong sequential consistency and are willing to accept minimal delays such that the document is always in a consistent state. However, it is not possible to maintain a single, global consistency level that meets both of these requirements, leading us to the question: can consistency be adapted or tuned at runtime in such a way as to provide more availability in low connectivity situations or for low conflict objects and strong consistency and correctness in optimal network conditions or for critical or high priority workloads?</td></tr>
<tr><th>Problem</th><td>as to</td></tr>
<tr><th>Solution</th><td>phrase "about" or leave out
  </td></tr>
<tr><th>Trigger</th><td> 'as to' in /Users/benjamin/.style-check.d/day-gastel:24</td></tr>
</table>
 phrase "about" or leave out
  (matched 'as to' in /Users/benjamin/.style-check.d/day-gastel:24)
<table id="a753a1add48fb67a94426dd983d27200b12ac9a1" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 343
, column: 617
)<div class="x"><button onclick="myFunction('a753a1add48fb67a94426dd983d27200b12ac9a1');">X</button></div></td></tr>
<tr><th>Original</th><td>Our preliminary solution is a hybridization of discrete consistency models as discussed earlier, which we have already begun exploring via the simulation as introduced in the preliminary work. The Federated Consistency model allows individual replicas to select their own local consistency policies and engage in replication according to the mechanism specified by the policy. Each replica maintains its own local state which is modified in response to local accesses as well as the receipt of messages from remote replicas. Each replica sends messages to other nodes in order to propagate the latest writes as well as to perform housekeeping. Therefore every replica can be seen as an event handler that responds to local access events as well as remote messages and generates more events (sent messages) in return. Simply put, so long as every federated replica has an event handler for all types of RPC messages, federation only has to be defined at the \textit{consistency boundaries}, that is when replicas of one consistency type send messages to that of another.</td></tr>
<tr><th>Problem</th><td>as to</td></tr>
<tr><th>Solution</th><td>phrase "about" or leave out
  </td></tr>
<tr><th>Trigger</th><td> 'as to' in /Users/benjamin/.style-check.d/day-gastel:24</td></tr>
</table>
 phrase "about" or leave out
  (matched 'as to' in /Users/benjamin/.style-check.d/day-gastel:24)
<table id="576de7a35155fc2ef5d72251dd12489a570b37c1" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 343
, column: 569
)<div class="x"><button onclick="myFunction('576de7a35155fc2ef5d72251dd12489a570b37c1');">X</button></div></td></tr>
<tr><th>Original</th><td>Our preliminary solution is a hybridization of discrete consistency models as discussed earlier, which we have already begun exploring via the simulation as introduced in the preliminary work. The Federated Consistency model allows individual replicas to select their own local consistency policies and engage in replication according to the mechanism specified by the policy. Each replica maintains its own local state which is modified in response to local accesses as well as the receipt of messages from remote replicas. Each replica sends messages to other nodes in order to propagate the latest writes as well as to perform housekeeping. Therefore every replica can be seen as an event handler that responds to local access events as well as remote messages and generates more events (sent messages) in return. Simply put, so long as every federated replica has an event handler for all types of RPC messages, federation only has to be defined at the \textit{consistency boundaries}, that is when replicas of one consistency type send messages to that of another.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="848a33203e31b0de375295e5921b260b0d81523f" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 343
, column: 623
)<div class="x"><button onclick="myFunction('848a33203e31b0de375295e5921b260b0d81523f');">X</button></div></td></tr>
<tr><th>Original</th><td>Our preliminary solution is a hybridization of discrete consistency models as discussed earlier, which we have already begun exploring via the simulation as introduced in the preliminary work. The Federated Consistency model allows individual replicas to select their own local consistency policies and engage in replication according to the mechanism specified by the policy. Each replica maintains its own local state which is modified in response to local accesses as well as the receipt of messages from remote replicas. Each replica sends messages to other nodes in order to propagate the latest writes as well as to perform housekeeping. Therefore every replica can be seen as an event handler that responds to local access events as well as remote messages and generates more events (sent messages) in return. Simply put, so long as every federated replica has an event handler for all types of RPC messages, federation only has to be defined at the \textit{consistency boundaries}, that is when replicas of one consistency type send messages to that of another.</td></tr>
<tr><th>Problem</th><td>perform</td></tr>
<tr><th>Solution</th><td>phrase "do"
  </td></tr>
<tr><th>Trigger</th><td> 'perform' in /Users/benjamin/.style-check.d/day-gastel:154</td></tr>
</table>
 phrase "do"
  (matched 'perform' in /Users/benjamin/.style-check.d/day-gastel:154)
<table id="c3b062165d182897037b39de9c4d2d9aec3dbabd" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 343
, column: 818
)<div class="x"><button onclick="myFunction('c3b062165d182897037b39de9c4d2d9aec3dbabd');">X</button></div></td></tr>
<tr><th>Original</th><td>Our preliminary solution is a hybridization of discrete consistency models as discussed earlier, which we have already begun exploring via the simulation as introduced in the preliminary work. The Federated Consistency model allows individual replicas to select their own local consistency policies and engage in replication according to the mechanism specified by the policy. Each replica maintains its own local state which is modified in response to local accesses as well as the receipt of messages from remote replicas. Each replica sends messages to other nodes in order to propagate the latest writes as well as to perform housekeeping. Therefore every replica can be seen as an event handler that responds to local access events as well as remote messages and generates more events (sent messages) in return. Simply put, so long as every federated replica has an event handler for all types of RPC messages, federation only has to be defined at the \textit{consistency boundaries}, that is when replicas of one consistency type send messages to that of another.</td></tr>
<tr><th>Problem</th><td>Simply</td></tr>
<tr><th>Solution</th><td>phrase probably isn't.
  </td></tr>
<tr><th>Trigger</th><td> 'simply' in /Users/benjamin/.style-check.d/my-rules:51</td></tr>
</table>
 phrase probably isn't.
  (matched 'simply' in /Users/benjamin/.style-check.d/my-rules:51)
<table id="b0eaa88edb4faef6e1b994da1cffbdf2ce06e089" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 347
, column: 852
)<div class="x"><button onclick="myFunction('b0eaa88edb4faef6e1b994da1cffbdf2ce06e089');">X</button></div></td></tr>
<tr><th>Original</th><td>A federated consistency protocol finds a middle ground in the trade-off between performance and consistency, particularly between an eventually consistent system implemented via gossip-based anti-entropy ~ and a sequential consistency model implemented by the Raft consensus protocol ~. By exploring these two extremes in the consistency spectrum we have observed in simulation that the overall number of inconsistencies in the system is reduced from the homogenous eventual system and that the access latency is decreased from the homogenous sequential system. Moreover, because the global consistency of the system is topology-dependent, it can be said to have flexible or dynamic consistency. We have found that large systems with variable latency in different geographic regions can perform well by allowing most nodes to operate in an optimistic fashion, but maintain a strong central quorum to reduce the amount of global conflict.</td></tr>
<tr><th>Problem</th><td>fashion</td></tr>
<tr><th>Solution</th><td>phrase hrm.
  </td></tr>
<tr><th>Trigger</th><td> 'fashion' in /Users/benjamin/.style-check.d/bad-words:5</td></tr>
</table>
 phrase hrm.
  (matched 'fashion' in /Users/benjamin/.style-check.d/bad-words:5)
<table id="57cf99df35d54c232f47f63c59f5052b5eef493d" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 347
, column: 788
)<div class="x"><button onclick="myFunction('57cf99df35d54c232f47f63c59f5052b5eef493d');">X</button></div></td></tr>
<tr><th>Original</th><td>A federated consistency protocol finds a middle ground in the trade-off between performance and consistency, particularly between an eventually consistent system implemented via gossip-based anti-entropy ~ and a sequential consistency model implemented by the Raft consensus protocol ~. By exploring these two extremes in the consistency spectrum we have observed in simulation that the overall number of inconsistencies in the system is reduced from the homogenous eventual system and that the access latency is decreased from the homogenous sequential system. Moreover, because the global consistency of the system is topology-dependent, it can be said to have flexible or dynamic consistency. We have found that large systems with variable latency in different geographic regions can perform well by allowing most nodes to operate in an optimistic fashion, but maintain a strong central quorum to reduce the amount of global conflict.</td></tr>
<tr><th>Problem</th><td>perform</td></tr>
<tr><th>Solution</th><td>phrase "do"
  </td></tr>
<tr><th>Trigger</th><td> 'perform' in /Users/benjamin/.style-check.d/day-gastel:154</td></tr>
</table>
 phrase "do"
  (matched 'perform' in /Users/benjamin/.style-check.d/day-gastel:154)
<table id="a58133e6febbfde9f76dc52eaa35906dc59e53c5" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 352
, column: 71
)<div class="x"><button onclick="myFunction('a58133e6febbfde9f76dc52eaa35906dc59e53c5');">X</button></div></td></tr>
<tr><th>Original</th><td>Eventual consistency allows replicas to operate in a highly available fashion at the risk of encountering some conflict (in the form of forks) that must be resolved in the future. We take the common approach of using periodic \textit{anti-entropy} sessions to converge replicas (e.g. reducing entropy, the divergence between the states of individual replicas) via a gossip protocol ~. Each replica periodically selects a random partner and sends a ~ message containing the latest version of all objects in the replica's local log. On receipt of the ~ message, the remote replica will compare the RPC object versions with those in its local log. If the RPC versions are later, it will append the later versions of the object to the log (\textit{last-writer wins}). However if the remote object version is later it will send that version back to the originating node in a ~ message. As a result, our anti-entropy implementation is \textit{bilateral}.</td></tr>
<tr><th>Problem</th><td>fashion</td></tr>
<tr><th>Solution</th><td>phrase hrm.
  </td></tr>
<tr><th>Trigger</th><td> 'fashion' in /Users/benjamin/.style-check.d/bad-words:5</td></tr>
</table>
 phrase hrm.
  (matched 'fashion' in /Users/benjamin/.style-check.d/bad-words:5)
<table id="d2295858de4e86d35ef3e62ea129339133c024d1" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 352
, column: 280
)<div class="x"><button onclick="myFunction('d2295858de4e86d35ef3e62ea129339133c024d1');">X</button></div></td></tr>
<tr><th>Original</th><td>Eventual consistency allows replicas to operate in a highly available fashion at the risk of encountering some conflict (in the form of forks) that must be resolved in the future. We take the common approach of using periodic \textit{anti-entropy} sessions to converge replicas (e.g. reducing entropy, the divergence between the states of individual replicas) via a gossip protocol ~. Each replica periodically selects a random partner and sends a ~ message containing the latest version of all objects in the replica's local log. On receipt of the ~ message, the remote replica will compare the RPC object versions with those in its local log. If the RPC versions are later, it will append the later versions of the object to the log (\textit{last-writer wins}). However if the remote object version is later it will send that version back to the originating node in a ~ message. As a result, our anti-entropy implementation is \textit{bilateral}.</td></tr>
<tr><th>Problem</th><td>e.g. </td></tr>
<tr><th>Solution</th><td>syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  </td></tr>
<tr><th>Trigger</th><td> 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33</td></tr>
</table>
 syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  (matched 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33)
<table id="564a6a8351736e216a8e1e0fb164408cbc8962b3" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 354
, column: 172
)<div class="x"><button onclick="myFunction('564a6a8351736e216a8e1e0fb164408cbc8962b3');">X</button></div></td></tr>
<tr><th>Original</th><td>Eventual consistency replicas read and write locally, resulting in essentially zero read and write latency. Forks are caused by the \textit{visibility latency}, i.e., the amount of time needed to propagate a write to the rest of the system. The visibility latency is dependent on the number of nodes in the topology and the anti-entropy interval, but because of the bilateral nature of our gossip protocol, has a logarithmic relationship to the number of nodes rather than a linear one.</td></tr>
<tr><th>Problem</th><td>amount of time</td></tr>
<tr><th>Solution</th><td>phrase "duration"
  </td></tr>
<tr><th>Trigger</th><td> 'amount of time' in /Users/benjamin/.style-check.d/verbose-phrases:209</td></tr>
</table>
 phrase "duration"
  (matched 'amount of time' in /Users/benjamin/.style-check.d/verbose-phrases:209)
<table id="cc281f8cba87786c5bc1ea4ad08678eda412fd0f" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 356
, column: 674
)<div class="x"><button onclick="myFunction('cc281f8cba87786c5bc1ea4ad08678eda412fd0f');">X</button></div></td></tr>
<tr><th>Original</th><td>The relationship between the anti-entropy delay and the size of the network relative to the mean time between accesses potentially means that eventual consistency would not cause forks. Said another way, nothing beats eventual consistency for availability and correctness given a fast enough network. Unfortunately, real-world networks are not ideal and conflicts in an eventual consistent system can lead to behaviors that are especially challenging in file systems. If a partition occurs and an object is forked, both sides of the eventually consistent system will continue allowing the branch to be extended, resulting in a difficult merge. Updates can also be ``stomped'', meaning that if they are not fully replicated they will not continue to be propagated if a later version exists. In order to provide stronger file system semantics, we propose to implement a core strong consistency consensus group that will improve the overall correctness of the system.</td></tr>
<tr><th>Problem</th><td>'',</td></tr>
<tr><th>Solution</th><td>syntax end quotes go outside punctuation like . and ,
  </td></tr>
<tr><th>Trigger</th><td> '''[\.,]' in /Users/benjamin/.style-check.d/common-typos:4</td></tr>
</table>
 syntax end quotes go outside punctuation like . and ,
  (matched '''[\.,]' in /Users/benjamin/.style-check.d/common-typos:4)
<table id="a210da6a02a1f884552a82606ad949e09e9b5db0" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 356
, column: 791
)<div class="x"><button onclick="myFunction('a210da6a02a1f884552a82606ad949e09e9b5db0');">X</button></div></td></tr>
<tr><th>Original</th><td>The relationship between the anti-entropy delay and the size of the network relative to the mean time between accesses potentially means that eventual consistency would not cause forks. Said another way, nothing beats eventual consistency for availability and correctness given a fast enough network. Unfortunately, real-world networks are not ideal and conflicts in an eventual consistent system can lead to behaviors that are especially challenging in file systems. If a partition occurs and an object is forked, both sides of the eventually consistent system will continue allowing the branch to be extended, resulting in a difficult merge. Updates can also be ``stomped'', meaning that if they are not fully replicated they will not continue to be propagated if a later version exists. In order to provide stronger file system semantics, we propose to implement a core strong consistency consensus group that will improve the overall correctness of the system.</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="69807d46a65b7aa4965a9b41c879948f1281b764" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 356
, column: 77
)<div class="x"><button onclick="myFunction('69807d46a65b7aa4965a9b41c879948f1281b764');">X</button></div></td></tr>
<tr><th>Original</th><td>The relationship between the anti-entropy delay and the size of the network relative to the mean time between accesses potentially means that eventual consistency would not cause forks. Said another way, nothing beats eventual consistency for availability and correctness given a fast enough network. Unfortunately, real-world networks are not ideal and conflicts in an eventual consistent system can lead to behaviors that are especially challenging in file systems. If a partition occurs and an object is forked, both sides of the eventually consistent system will continue allowing the branch to be extended, resulting in a difficult merge. Updates can also be ``stomped'', meaning that if they are not fully replicated they will not continue to be propagated if a later version exists. In order to provide stronger file system semantics, we propose to implement a core strong consistency consensus group that will improve the overall correctness of the system.</td></tr>
<tr><th>Problem</th><td>relative to</td></tr>
<tr><th>Solution</th><td>phrase "about"
  </td></tr>
<tr><th>Trigger</th><td> 'relative to' in /Users/benjamin/.style-check.d/day-gastel:168</td></tr>
</table>
 phrase "about"
  (matched 'relative to' in /Users/benjamin/.style-check.d/day-gastel:168)
<table id="52d29eed275040878614958bad6ef9e1f90b10d8" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 361
, column: 199
)<div class="x"><button onclick="myFunction('52d29eed275040878614958bad6ef9e1f90b10d8');">X</button></div></td></tr>
<tr><th>Original</th><td>We implement sequentially consistent replicated logs via the Raft consensus algorithm~. However, consensus alone does not ensure that sequentially consistent file system accesses are guaranteed and a number of policy decisions about how Raft followers read, write and interact with the leader must be discussed. In order to present the possibilities for policies in our system, we must understand the background of the Raft protocol's implementation of sequential consistency.</td></tr>
<tr><th>Problem</th><td>a number of</td></tr>
<tr><th>Solution</th><td>phrase getting the verb agreement for this useless phrase is tricky.
  </td></tr>
<tr><th>Trigger</th><td> 'a number of' in /Users/benjamin/.style-check.d/verbose-phrases:5</td></tr>
</table>
 phrase getting the verb agreement for this useless phrase is tricky.
  (matched 'a number of' in /Users/benjamin/.style-check.d/verbose-phrases:5)
<table id="7970cfae824534dc8e69695ea4ff0a712dfe8b68" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 361
, column: 313
)<div class="x"><button onclick="myFunction('7970cfae824534dc8e69695ea4ff0a712dfe8b68');">X</button></div></td></tr>
<tr><th>Original</th><td>We implement sequentially consistent replicated logs via the Raft consensus algorithm~. However, consensus alone does not ensure that sequentially consistent file system accesses are guaranteed and a number of policy decisions about how Raft followers read, write and interact with the leader must be discussed. In order to present the possibilities for policies in our system, we must understand the background of the Raft protocol's implementation of sequential consistency.</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="cd8e3c021c2f3e5b7f8bae25f29b8902387ecfea" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 363
, column: 404
)<div class="x"><button onclick="myFunction('cd8e3c021c2f3e5b7f8bae25f29b8902387ecfea');">X</button></div></td></tr>
<tr><th>Original</th><td>The Raft leader has the primary responsibility of coordinating all other Raft replicas and therefore is also primarily responsible for ensuring a sequentially consistent system that maintains file system consistency invariants. A write access that originates at a follower must be sent as a ~ to the leader. The leader accepts writes in the order that they are received, and if the leader detects a fork -- that is that a write has a parent version who already has a child version in the log -- Raft will simply reject (drop) the write. In order to minimize the number of messages that Raft sends, Raft will aggregate all writes into the next ~ message and send them together.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax that's an en-dash, you want an em-dash: "---"
  </td></tr>
<tr><th>Trigger</th><td> '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24</td></tr>
</table>
 syntax that's an en-dash, you want an em-dash: "---"
  (matched '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24)
<table id="feebc8141cf23a5f32707f692161f93818d8bffd" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 363
, column: 538
)<div class="x"><button onclick="myFunction('feebc8141cf23a5f32707f692161f93818d8bffd');">X</button></div></td></tr>
<tr><th>Original</th><td>The Raft leader has the primary responsibility of coordinating all other Raft replicas and therefore is also primarily responsible for ensuring a sequentially consistent system that maintains file system consistency invariants. A write access that originates at a follower must be sent as a ~ to the leader. The leader accepts writes in the order that they are received, and if the leader detects a fork -- that is that a write has a parent version who already has a child version in the log -- Raft will simply reject (drop) the write. In order to minimize the number of messages that Raft sends, Raft will aggregate all writes into the next ~ message and send them together.</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="cd8e3c021c2f3e5b7f8bae25f29b8902387ecfea" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 363
, column: 404
)<div class="x"><button onclick="myFunction('cd8e3c021c2f3e5b7f8bae25f29b8902387ecfea');">X</button></div></td></tr>
<tr><th>Original</th><td>The Raft leader has the primary responsibility of coordinating all other Raft replicas and therefore is also primarily responsible for ensuring a sequentially consistent system that maintains file system consistency invariants. A write access that originates at a follower must be sent as a ~ to the leader. The leader accepts writes in the order that they are received, and if the leader detects a fork -- that is that a write has a parent version who already has a child version in the log -- Raft will simply reject (drop) the write. In order to minimize the number of messages that Raft sends, Raft will aggregate all writes into the next ~ message and send them together.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax the en-dash should be between numbers.
  </td></tr>
<tr><th>Trigger</th><td> '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13</td></tr>
</table>
 syntax the en-dash should be between numbers.
  (matched '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13)
<table id="0c7b1c46e8e7731a8d3d28f54985a5716086a424" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 363
, column: 506
)<div class="x"><button onclick="myFunction('0c7b1c46e8e7731a8d3d28f54985a5716086a424');">X</button></div></td></tr>
<tr><th>Original</th><td>The Raft leader has the primary responsibility of coordinating all other Raft replicas and therefore is also primarily responsible for ensuring a sequentially consistent system that maintains file system consistency invariants. A write access that originates at a follower must be sent as a ~ to the leader. The leader accepts writes in the order that they are received, and if the leader detects a fork -- that is that a write has a parent version who already has a child version in the log -- Raft will simply reject (drop) the write. In order to minimize the number of messages that Raft sends, Raft will aggregate all writes into the next ~ message and send them together.</td></tr>
<tr><th>Problem</th><td>simply</td></tr>
<tr><th>Solution</th><td>phrase probably isn't.
  </td></tr>
<tr><th>Trigger</th><td> 'simply' in /Users/benjamin/.style-check.d/my-rules:51</td></tr>
</table>
 phrase probably isn't.
  (matched 'simply' in /Users/benjamin/.style-check.d/my-rules:51)
<table id="1806a764b2c6df6ac47f7cc105db55fe60c56ebd" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 365
, column: 314
)<div class="x"><button onclick="myFunction('1806a764b2c6df6ac47f7cc105db55fe60c56ebd');">X</button></div></td></tr>
<tr><th>Original</th><td>The aggregation of writes and latency of coordination messages means that there is a delay between leadership decisions and follower actions. As a result, write accesses are dependent on the response time of the leader but could also be dropped, requiring the accessor to retry or to handle the conflict somehow. In order to make progress, followers must decide how to read a parent version in order to make a write. There are several options, each providing a varying level of safety, minimizing the risk of a stale read:</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="6c33ab660a581b5545d0983c0bb53ce874bc60fc" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 365
, column: 282
)<div class="x"><button onclick="myFunction('6c33ab660a581b5545d0983c0bb53ce874bc60fc');">X</button></div></td></tr>
<tr><th>Original</th><td>The aggregation of writes and latency of coordination messages means that there is a delay between leadership decisions and follower actions. As a result, write accesses are dependent on the response time of the leader but could also be dropped, requiring the accessor to retry or to handle the conflict somehow. In order to make progress, followers must decide how to read a parent version in order to make a write. There are several options, each providing a varying level of safety, minimizing the risk of a stale read:</td></tr>
<tr><th>Problem</th><td>to handle</td></tr>
<tr><th>Solution</th><td>phrase use a more specific verb like address, treat, solve
  </td></tr>
<tr><th>Trigger</th><td> '(we|to) handle' in /Users/benjamin/.style-check.d/verbose-phrases:108</td></tr>
</table>
 phrase use a more specific verb like address, treat, solve
  (matched '(we|to) handle' in /Users/benjamin/.style-check.d/verbose-phrases:108)
<table id="fcd1590b59ca9b211bede50d8ce65ce8dfa7c932" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 368
, column: 238
)<div class="x"><button onclick="myFunction('fcd1590b59ca9b211bede50d8ce65ce8dfa7c932');">X</button></div></td></tr>
<tr><th>Original</th><td>    \item \textit{READ COMMITTED} Raft replicas will only read the latest committed version of an object, guaranteeing that the write will not be rolled back in the case of an outage. However, this read mode introduces the potential for a lot of staleness and therefore forks.</td></tr>
<tr><th>Problem</th><td>a lot of</td></tr>
<tr><th>Solution</th><td>phrase "many"
  </td></tr>
<tr><th>Trigger</th><td> 'a lot of' in /Users/benjamin/.style-check.d/verbose-phrases:202</td></tr>
</table>
 phrase "many"
  (matched 'a lot of' in /Users/benjamin/.style-check.d/verbose-phrases:202)
<table id="0dd566cb782941f87868e1d88e37b7a84c9dfdaf" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 370
, column: 58
)<div class="x"><button onclick="myFunction('0dd566cb782941f87868e1d88e37b7a84c9dfdaf');">X</button></div></td></tr>
<tr><th>Original</th><td>    \item \textit{REMOTE READ} Rather than read locally, simply request the latest version from the leader. This introduces the potential for additional latency, but may be faster if the expected message latency is less than the heartbeat interval.</td></tr>
<tr><th>Problem</th><td>simply</td></tr>
<tr><th>Solution</th><td>phrase probably isn't.
  </td></tr>
<tr><th>Trigger</th><td> 'simply' in /Users/benjamin/.style-check.d/my-rules:51</td></tr>
</table>
 phrase probably isn't.
  (matched 'simply' in /Users/benjamin/.style-check.d/my-rules:51)
<table id="c439a3734f330d7d62ae00aed1b72a6009b1a828" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 373
, column: 378
)<div class="x"><button onclick="myFunction('c439a3734f330d7d62ae00aed1b72a6009b1a828');">X</button></div></td></tr>
<tr><th>Original</th><td>Each of these options has critical implications for the likelihood of stale reads and forks in the system. Replicas would choose read committed if the network was highly partition prone and messages from the leader were unstable and prone to being rolled back. Remote read servers replicas well when the average message latency is far lower than the heartbeat interval, though this could be improved by making the heartbeat interval similar to the network latency. For this reason, we propose \textit{read latest} as the most likely scenario for a file system implementing sequential consistency with Raft.</td></tr>
<tr><th>Problem</th><td>this could</td></tr>
<tr><th>Solution</th><td>phrase this "what" could
  </td></tr>
<tr><th>Trigger</th><td> 'this could' in /Users/benjamin/.style-check.d/my-rules:49</td></tr>
</table>
 phrase this "what" could
  (matched 'this could' in /Users/benjamin/.style-check.d/my-rules:49)
<table id="405b697ceb84f915c829380d48b17048809ce21e" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 378
, column: 121
)<div class="x"><button onclick="myFunction('405b697ceb84f915c829380d48b17048809ce21e');">X</button></div></td></tr>
<tr><th>Original</th><td>A key requirement of Federated Consistency is the opportunity to create heterogeneous systems with no performance cost, e.g. a homogenous eventual cloud and a homogenous Raft cloud will continue to perform equivalently whether or not they participate in a federated cloud. However, we posit that an eventual cloud should benefit in lowered data staleness and in fork frequency from being connected to a strong, central consensus group. Similarly, Raft nodes should be able to use anti-entropy mechanisms to replicate data and continue writing even if the leader is unavailable and no consensus can be reached to elect a leader. The question is therefore how to integrate the eventual consistency via gossip and sequential consistency via consensus in a non-invasive way.</td></tr>
<tr><th>Problem</th><td>e.g. </td></tr>
<tr><th>Solution</th><td>syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  </td></tr>
<tr><th>Trigger</th><td> 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33</td></tr>
</table>
 syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  (matched 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33)
<table id="5fb2859423394775a0ebb4c3262b2065d308aaad" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 378
, column: 199
)<div class="x"><button onclick="myFunction('5fb2859423394775a0ebb4c3262b2065d308aaad');">X</button></div></td></tr>
<tr><th>Original</th><td>A key requirement of Federated Consistency is the opportunity to create heterogeneous systems with no performance cost, e.g. a homogenous eventual cloud and a homogenous Raft cloud will continue to perform equivalently whether or not they participate in a federated cloud. However, we posit that an eventual cloud should benefit in lowered data staleness and in fork frequency from being connected to a strong, central consensus group. Similarly, Raft nodes should be able to use anti-entropy mechanisms to replicate data and continue writing even if the leader is unavailable and no consensus can be reached to elect a leader. The question is therefore how to integrate the eventual consistency via gossip and sequential consistency via consensus in a non-invasive way.</td></tr>
<tr><th>Problem</th><td>perform</td></tr>
<tr><th>Solution</th><td>phrase "do"
  </td></tr>
<tr><th>Trigger</th><td> 'perform' in /Users/benjamin/.style-check.d/day-gastel:154</td></tr>
</table>
 phrase "do"
  (matched 'perform' in /Users/benjamin/.style-check.d/day-gastel:154)
<table id="725d4708e304f9efbacd44455e5a08163cc42825" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 382
, column: 835
)<div class="x"><button onclick="myFunction('725d4708e304f9efbacd44455e5a08163cc42825');">X</button></div></td></tr>
<tr><th>Original</th><td>In order to federated multiple consistency models, there are two integration points: communication and consistency. Our initial approach was to integrate communication at the Raft nodes, by allowing Raft nodes to participate in anti-entropy with the eventual cloud (but not other Raft nodes). Eventual nodes therefore ``synchronize'' with a local Raft node (modified by some synchronization probability) by exchanging ~ messages with the Raft nodes. A slight increase in the synchronization probability balanced the amount of synchronization with the amount of communication in the eventual cloud given the imbalance in the ratio of eventual nodes to Raft nodes. In order to manage the communications delay between the anti-entropy timeout and leadership coordination, Raft nodes must keep local caches of forked or dropped writes so as to not propagate them back to the eventual cloud or replay them to the leader. However, we have observed that this was not enough to stop the eventual cloud from propagating a fork around Raft, causing further inconsistencies.</td></tr>
<tr><th>Problem</th><td>as to</td></tr>
<tr><th>Solution</th><td>phrase "about" or leave out
  </td></tr>
<tr><th>Trigger</th><td> 'as to' in /Users/benjamin/.style-check.d/day-gastel:24</td></tr>
</table>
 phrase "about" or leave out
  (matched 'as to' in /Users/benjamin/.style-check.d/day-gastel:24)
<table id="d7aaf36225d5fddb7527046ac19028216f07dee2" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 382
, column: 1
)<div class="x"><button onclick="myFunction('d7aaf36225d5fddb7527046ac19028216f07dee2');">X</button></div></td></tr>
<tr><th>Original</th><td>In order to federated multiple consistency models, there are two integration points: communication and consistency. Our initial approach was to integrate communication at the Raft nodes, by allowing Raft nodes to participate in anti-entropy with the eventual cloud (but not other Raft nodes). Eventual nodes therefore ``synchronize'' with a local Raft node (modified by some synchronization probability) by exchanging ~ messages with the Raft nodes. A slight increase in the synchronization probability balanced the amount of synchronization with the amount of communication in the eventual cloud given the imbalance in the ratio of eventual nodes to Raft nodes. In order to manage the communications delay between the anti-entropy timeout and leadership coordination, Raft nodes must keep local caches of forked or dropped writes so as to not propagate them back to the eventual cloud or replay them to the leader. However, we have observed that this was not enough to stop the eventual cloud from propagating a fork around Raft, causing further inconsistencies.</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="eb0742ecdd22c979ac8ab598807320f3c1cf4bf3" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 382
, column: 832
)<div class="x"><button onclick="myFunction('eb0742ecdd22c979ac8ab598807320f3c1cf4bf3');">X</button></div></td></tr>
<tr><th>Original</th><td>In order to federated multiple consistency models, there are two integration points: communication and consistency. Our initial approach was to integrate communication at the Raft nodes, by allowing Raft nodes to participate in anti-entropy with the eventual cloud (but not other Raft nodes). Eventual nodes therefore ``synchronize'' with a local Raft node (modified by some synchronization probability) by exchanging ~ messages with the Raft nodes. A slight increase in the synchronization probability balanced the amount of synchronization with the amount of communication in the eventual cloud given the imbalance in the ratio of eventual nodes to Raft nodes. In order to manage the communications delay between the anti-entropy timeout and leadership coordination, Raft nodes must keep local caches of forked or dropped writes so as to not propagate them back to the eventual cloud or replay them to the leader. However, we have observed that this was not enough to stop the eventual cloud from propagating a fork around Raft, causing further inconsistencies.</td></tr>
<tr><th>Problem</th><td>so as to</td></tr>
<tr><th>Solution</th><td>phrase "to"
  </td></tr>
<tr><th>Trigger</th><td> 'so as to' in /Users/benjamin/.style-check.d/day-gastel:174</td></tr>
</table>
 phrase "to"
  (matched 'so as to' in /Users/benjamin/.style-check.d/day-gastel:174)
<table id="cafe36e508a5d019791c650795cf14eb741c2e77" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 384
, column: 423
)<div class="x"><button onclick="myFunction('cafe36e508a5d019791c650795cf14eb741c2e77');">X</button></div></td></tr>
<tr><th>Original</th><td>Our approach to integrate consistency is to extend each version number with an additional monotonically increasing counter called the \textit{forte} (strong) version that can only be incremented by the leader of the Raft quorum. Because the Raft leader dropped forks or any version that was not more recent than the latest version, incrementing the forte number on commit ensures that only consistent versions are marked. In order to determine the latest version, the forte number is compared first, then the version number, allowing Raft to ``bump'' the consistent version to a more recent version. In order to prevent that version's children from becoming less recent, on receipt of a version with a higher forte than the local, eventual nodes must search for the forte entry in their local log, find all children of the update, and set the child version's forte equal to that of the parent.</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="00de0ec0aa75f3adaaf91d32cf8eff271227a10b" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 386
, column: 618
)<div class="x"><button onclick="myFunction('00de0ec0aa75f3adaaf91d32cf8eff271227a10b');">X</button></div></td></tr>
<tr><th>Original</th><td>Our preliminary investigations show that this integration works well to curb inconsistencies due to anti-entropy delays as well as those introduced by communication integration. There are, however, quite a few knobs to turn in the system described above. Further investigation into smoothing integration points between consistency protocols and the policies that each define may lead to smoother messaging with fewer resource constraints. We have identified a current bottleneck in the system however: the leadership of the central quorum, through which every single write must pass, no matter the size of the cloud. In order to address this, we propose an adaptation to the central consensus group such that it can provide Hierarchical Consensus.</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="ee141ab3900293a69582ed8e1733b586a5329ffb" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 386
, column: 59
)<div class="x"><button onclick="myFunction('ee141ab3900293a69582ed8e1733b586a5329ffb');">X</button></div></td></tr>
<tr><th>Original</th><td>Our preliminary investigations show that this integration works well to curb inconsistencies due to anti-entropy delays as well as those introduced by communication integration. There are, however, quite a few knobs to turn in the system described above. Further investigation into smoothing integration points between consistency protocols and the policies that each define may lead to smoother messaging with fewer resource constraints. We have identified a current bottleneck in the system however: the leadership of the central quorum, through which every single write must pass, no matter the size of the cloud. In order to address this, we propose an adaptation to the central consensus group such that it can provide Hierarchical Consensus.</td></tr>
<tr><th>Problem</th><td>works well</td></tr>
<tr><th>Solution</th><td>phrase be more specific.
  </td></tr>
<tr><th>Trigger</th><td> 'works well' in /Users/benjamin/.style-check.d/verbose-phrases:167</td></tr>
</table>
 phrase be more specific.
  (matched 'works well' in /Users/benjamin/.style-check.d/verbose-phrases:167)
<table id="cd39fe915a408656bef33718df949846e4749273" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 391
, column: 99
)<div class="x"><button onclick="myFunction('cd39fe915a408656bef33718df949846e4749273');">X</button></div></td></tr>
<tr><th>Original</th><td>We have already begun to investigate Federated Consistency, utilizing the simulation described in Section \ref{sec:preliminary_work} and plan to submit these results to ICDCS 2017 in December. Our approach focused on two primary experiments: isolating the effect of increasing and more variable latency on consistency protocols and exploring the relationship of conflict likelihood to consistency. In both experiments we fixed as many variables as possible. Each simulation received identical topologies as shown in Figure \ref{fig:topology}: five locations with 4 replica servers in each. Federated Consistency specifies a topology of one Raft replica server per location and all other devices eventually consistent. Each simulation also received identical workloads totaling approximately 28,000 access events across all devices (both reads and writes) to a namespace of 20 objects per replica server. Timing parameters for each protocol -- homogenous Raft, eventual consistency, and Federated Consistency -- were computed with a ``tick'' parameter, $T$, to preserve the relationship between each protocol and the network environment.</td></tr>
<tr><th>Problem</th><td>Section \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="e71cc3173d7b35bde81d54135867de7f3dd63993" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 391
, column: 898
)<div class="x"><button onclick="myFunction('e71cc3173d7b35bde81d54135867de7f3dd63993');">X</button></div></td></tr>
<tr><th>Original</th><td>We have already begun to investigate Federated Consistency, utilizing the simulation described in Section ~ and plan to submit these results to ICDCS 2017 in December. Our approach focused on two primary experiments: isolating the effect of increasing and more variable latency on consistency protocols and exploring the relationship of conflict likelihood to consistency. In both experiments we fixed as many variables as possible. Each simulation received identical topologies as shown in Figure ~: five locations with 4 replica servers in each. Federated Consistency specifies a topology of one Raft replica server per location and all other devices eventually consistent. Each simulation also received identical workloads totaling approximately 28,000 access events across all devices (both reads and writes) to a namespace of 20 objects per replica server. Timing parameters for each protocol -- homogenous Raft, eventual consistency, and Federated Consistency -- were computed with a ``tick'' parameter,~, to preserve the relationship between each protocol and the network environment.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax that's an en-dash, you want an em-dash: "---"
  </td></tr>
<tr><th>Trigger</th><td> '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24</td></tr>
</table>
 syntax that's an en-dash, you want an em-dash: "---"
  (matched '[\n ]--[\n ]' in /Users/benjamin/.style-check.d/common-typos:24)
<table id="e71cc3173d7b35bde81d54135867de7f3dd63993" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 391
, column: 898
)<div class="x"><button onclick="myFunction('e71cc3173d7b35bde81d54135867de7f3dd63993');">X</button></div></td></tr>
<tr><th>Original</th><td>We have already begun to investigate Federated Consistency, utilizing the simulation described in Section ~ and plan to submit these results to ICDCS 2017 in December. Our approach focused on two primary experiments: isolating the effect of increasing and more variable latency on consistency protocols and exploring the relationship of conflict likelihood to consistency. In both experiments we fixed as many variables as possible. Each simulation received identical topologies as shown in Figure ~: five locations with 4 replica servers in each. Federated Consistency specifies a topology of one Raft replica server per location and all other devices eventually consistent. Each simulation also received identical workloads totaling approximately 28,000 access events across all devices (both reads and writes) to a namespace of 20 objects per replica server. Timing parameters for each protocol -- homogenous Raft, eventual consistency, and Federated Consistency -- were computed with a ``tick'' parameter,~, to preserve the relationship between each protocol and the network environment.</td></tr>
<tr><th>Problem</th><td> -- </td></tr>
<tr><th>Solution</th><td>syntax the en-dash should be between numbers.
  </td></tr>
<tr><th>Trigger</th><td> '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13</td></tr>
</table>
 syntax the en-dash should be between numbers.
  (matched '[ \n]--[ \n]' in /Users/benjamin/.style-check.d/latex-checking:13)
<table id="81cfe3c520615a35a3fe482998416959b11ad4d2" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 391
, column: 819
)<div class="x"><button onclick="myFunction('81cfe3c520615a35a3fe482998416959b11ad4d2');">X</button></div></td></tr>
<tr><th>Original</th><td>We have already begun to investigate Federated Consistency, utilizing the simulation described in Section ~ and plan to submit these results to ICDCS 2017 in December. Our approach focused on two primary experiments: isolating the effect of increasing and more variable latency on consistency protocols and exploring the relationship of conflict likelihood to consistency. In both experiments we fixed as many variables as possible. Each simulation received identical topologies as shown in Figure ~: five locations with 4 replica servers in each. Federated Consistency specifies a topology of one Raft replica server per location and all other devices eventually consistent. Each simulation also received identical workloads totaling approximately 28,000 access events across all devices (both reads and writes) to a namespace of 20 objects per replica server. Timing parameters for each protocol -- homogenous Raft, eventual consistency, and Federated Consistency -- were computed with a ``tick'' parameter,~, to preserve the relationship between each protocol and the network environment.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="ad3af9f564af9ca1f74b209651b24626bbd29dc5" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 409
, column: 531
)<div class="x"><button onclick="myFunction('ad3af9f564af9ca1f74b209651b24626bbd29dc5');">X</button></div></td></tr>
<tr><th>Original</th><td>The results of the latency variation experiment shows that network environment has a strong influence on consistency; moreover it shows that Federated Consistency balances the inconsistencies between eventual and Raft, providing more stable consistency guarantees even in variable environments. Both Figures \ref{fig:latency_forked_writes} and \ref{fig:latency_stale_reads} show a cross-over point where at the lower latency and variability, Raft performs better in terms of percent of forks and stale reads, then around 600ms in Figure \ref{fig:latency_forked_writes}, eventual starts to outperform Raft. However, no matter the latency distribution, Federated performs equivalently with the better performing protocol, particularly for the conservative timing parameter.</td></tr>
<tr><th>Problem</th><td>Figure \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="f26449b1f261aa1310bc149841a065b94ac31851" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 409
, column: 466
)<div class="x"><button onclick="myFunction('f26449b1f261aa1310bc149841a065b94ac31851');">X</button></div></td></tr>
<tr><th>Original</th><td>The results of the latency variation experiment shows that network environment has a strong influence on consistency; moreover it shows that Federated Consistency balances the inconsistencies between eventual and Raft, providing more stable consistency guarantees even in variable environments. Both Figures ~ and ~ show a cross-over point where at the lower latency and variability, Raft performs better in terms of percent of forks and stale reads, then around 600ms in Figure ~, eventual starts to outperform Raft. However, no matter the latency distribution, Federated performs equivalently with the better performing protocol, particularly for the conservative timing parameter.</td></tr>
<tr><th>Problem</th><td>0ms</td></tr>
<tr><th>Solution</th><td>syntax put a space between the number and the unit.
  </td></tr>
<tr><th>Trigger</th><td> '[0-9]ms' in /Users/benjamin/.style-check.d/common-typos:8</td></tr>
</table>
 syntax put a space between the number and the unit.
  (matched '[0-9]ms' in /Users/benjamin/.style-check.d/common-typos:8)
<table id="15f23869749a5267f9be35eb40166e7cb57080dd" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 409
, column: 406
)<div class="x"><button onclick="myFunction('15f23869749a5267f9be35eb40166e7cb57080dd');">X</button></div></td></tr>
<tr><th>Original</th><td>The results of the latency variation experiment shows that network environment has a strong influence on consistency; moreover it shows that Federated Consistency balances the inconsistencies between eventual and Raft, providing more stable consistency guarantees even in variable environments. Both Figures ~ and ~ show a cross-over point where at the lower latency and variability, Raft performs better in terms of percent of forks and stale reads, then around 600ms in Figure ~, eventual starts to outperform Raft. However, no matter the latency distribution, Federated performs equivalently with the better performing protocol, particularly for the conservative timing parameter.</td></tr>
<tr><th>Problem</th><td>in terms of</td></tr>
<tr><th>Solution</th><td>phrase don't need this.
  </td></tr>
<tr><th>Trigger</th><td> 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136</td></tr>
</table>
 phrase don't need this.
  (matched 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136)
<table id="58c0594092c2fb550cfcdb39b349c810bdb1e61e" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 425
, column: 468
)<div class="x"><button onclick="myFunction('58c0594092c2fb550cfcdb39b349c810bdb1e61e');">X</button></div></td></tr>
<tr><th>Original</th><td>The second experiment fixed the latency distribution and instead varied the probability of conflict, e.g. at $P_c=0.0$ each device accessed their own, independent namespace and at $P_c=1.0$ each device shared the exact same namespace. Note that at $P_c=0.0$ forks are impossible, but stale reads are in the case of Raft: a device can read a stale version of it's own write while awaiting a commit or response from the leader depending on the read policy described in Section \ref{sec:core_consensus}. As shown in Figure \ref{fig:conflict_forked_writes}, Federated has fewer forks than an eventually consistent system, thanks to the core consensus group. Federated also performs no worse than Raft in terms of stale reads as shown in Figure \ref{fig:conflict_stale_reads}. When considering inconsistencies, Raft only improves the performance of eventual, but only provides performance benefits to the Raft core group, this is why Federated would benefit from a more available core consensus group, which we propose can be implemented via Hierarchical Consensus.</td></tr>
<tr><th>Problem</th><td>Section \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="8cb1ec169b4d247a1a9fd99f22a53eb8e29d4721" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 425
, column: 102
)<div class="x"><button onclick="myFunction('8cb1ec169b4d247a1a9fd99f22a53eb8e29d4721');">X</button></div></td></tr>
<tr><th>Original</th><td>The second experiment fixed the latency distribution and instead varied the probability of conflict, e.g. at~ forks are impossible, but stale reads are in the case of Raft: a device can read a stale version of it's own write while awaiting a commit or response from the leader depending on the read policy described in Section ~. As shown in Figure ~, Federated has fewer forks than an eventually consistent system, thanks to the core consensus group. Federated also performs no worse than Raft in terms of stale reads as shown in Figure ~. When considering inconsistencies, Raft only improves the performance of eventual, but only provides performance benefits to the Raft core group, this is why Federated would benefit from a more available core consensus group, which we propose can be implemented via Hierarchical Consensus.</td></tr>
<tr><th>Problem</th><td>e.g. </td></tr>
<tr><th>Solution</th><td>syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  </td></tr>
<tr><th>Trigger</th><td> 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33</td></tr>
</table>
 syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  (matched 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33)
<table id="3e7e47ecbfc68b6ac5719c2d4396c615b1c93924" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 425
, column: 496
)<div class="x"><button onclick="myFunction('3e7e47ecbfc68b6ac5719c2d4396c615b1c93924');">X</button></div></td></tr>
<tr><th>Original</th><td>The second experiment fixed the latency distribution and instead varied the probability of conflict, e.g. at~ forks are impossible, but stale reads are in the case of Raft: a device can read a stale version of it's own write while awaiting a commit or response from the leader depending on the read policy described in Section ~. As shown in Figure ~, Federated has fewer forks than an eventually consistent system, thanks to the core consensus group. Federated also performs no worse than Raft in terms of stale reads as shown in Figure ~. When considering inconsistencies, Raft only improves the performance of eventual, but only provides performance benefits to the Raft core group, this is why Federated would benefit from a more available core consensus group, which we propose can be implemented via Hierarchical Consensus.</td></tr>
<tr><th>Problem</th><td>in terms of</td></tr>
<tr><th>Solution</th><td>phrase don't need this.
  </td></tr>
<tr><th>Trigger</th><td> 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136</td></tr>
</table>
 phrase don't need this.
  (matched 'in terms of' in /Users/benjamin/.style-check.d/verbose-phrases:136)
<table id="d16ff65d872b7c22b325df937bdca1d628271122" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 425
, column: 54
)<div class="x"><button onclick="myFunction('d16ff65d872b7c22b325df937bdca1d628271122');">X</button></div></td></tr>
<tr><th>Original</th><td>The second experiment fixed the latency distribution and instead varied the probability of conflict, e.g. at~ forks are impossible, but stale reads are in the case of Raft: a device can read a stale version of it's own write while awaiting a commit or response from the leader depending on the read policy described in Section ~. As shown in Figure ~, Federated has fewer forks than an eventually consistent system, thanks to the core consensus group. Federated also performs no worse than Raft in terms of stale reads as shown in Figure ~. When considering inconsistencies, Raft only improves the performance of eventual, but only provides performance benefits to the Raft core group, this is why Federated would benefit from a more available core consensus group, which we propose can be implemented via Hierarchical Consensus.</td></tr>
<tr><th>Problem</th><td>and instead</td></tr>
<tr><th>Solution</th><td>phrase replace with but?
  </td></tr>
<tr><th>Trigger</th><td> 'and instead' in /Users/benjamin/.style-check.d/verbose-phrases:11</td></tr>
</table>
 phrase replace with but?
  (matched 'and instead' in /Users/benjamin/.style-check.d/verbose-phrases:11)
<table id="39d0665432d4b9a650bd947497b7ad231faaf270" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 430
, column: 164
)<div class="x"><button onclick="myFunction('39d0665432d4b9a650bd947497b7ad231faaf270');">X</button></div></td></tr>
<tr><th>Original</th><td>Federated consistency presents the opportunity to extend distributed storage systems to medium to large scale networks comprised of dozens of replica servers even in the face of high variability in unstable, mobile network environments. By allowing replicas to participate in eventual consistency replication if required to maintain a minimum quality of service, the system becomes flexible enough to handle variability. The key to Federation, however, is the strong central quorum that coordinates partitions in the eventual cloud, handling conflicts and pruning forked branches, minimizing overall inconsistency in the system.</td></tr>
<tr><th>Problem</th><td>in the face of</td></tr>
<tr><th>Solution</th><td>phrase can be overused.  try despite?
  </td></tr>
<tr><th>Trigger</th><td> 'in the face of' in /Users/benjamin/.style-check.d/verbose-phrases:84</td></tr>
</table>
 phrase can be overused.  try despite?
  (matched 'in the face of' in /Users/benjamin/.style-check.d/verbose-phrases:84)
<table id="56dbd4c3c332017165f1af5dde819c7816c3be37" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 430
, column: 399
)<div class="x"><button onclick="myFunction('56dbd4c3c332017165f1af5dde819c7816c3be37');">X</button></div></td></tr>
<tr><th>Original</th><td>Federated consistency presents the opportunity to extend distributed storage systems to medium to large scale networks comprised of dozens of replica servers even in the face of high variability in unstable, mobile network environments. By allowing replicas to participate in eventual consistency replication if required to maintain a minimum quality of service, the system becomes flexible enough to handle variability. The key to Federation, however, is the strong central quorum that coordinates partitions in the eventual cloud, handling conflicts and pruning forked branches, minimizing overall inconsistency in the system.</td></tr>
<tr><th>Problem</th><td>to handle</td></tr>
<tr><th>Solution</th><td>phrase use a more specific verb like address, treat, solve
  </td></tr>
<tr><th>Trigger</th><td> '(we|to) handle' in /Users/benjamin/.style-check.d/verbose-phrases:108</td></tr>
</table>
 phrase use a more specific verb like address, treat, solve
  (matched '(we|to) handle' in /Users/benjamin/.style-check.d/verbose-phrases:108)
<table id="1f288b4c444d74bdc9ae3e383ee301dee57148c1" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 430
, column: 534
)<div class="x"><button onclick="myFunction('1f288b4c444d74bdc9ae3e383ee301dee57148c1');">X</button></div></td></tr>
<tr><th>Original</th><td>Federated consistency presents the opportunity to extend distributed storage systems to medium to large scale networks comprised of dozens of replica servers even in the face of high variability in unstable, mobile network environments. By allowing replicas to participate in eventual consistency replication if required to maintain a minimum quality of service, the system becomes flexible enough to handle variability. The key to Federation, however, is the strong central quorum that coordinates partitions in the eventual cloud, handling conflicts and pruning forked branches, minimizing overall inconsistency in the system.</td></tr>
<tr><th>Problem</th><td>handling</td></tr>
<tr><th>Solution</th><td>phrase use a more specific verb like addressing, treating, solving, mitigating (unless handling errors or exceptions)
  </td></tr>
<tr><th>Trigger</th><td> 'handling' in /Users/benjamin/.style-check.d/verbose-phrases:109</td></tr>
</table>
 phrase use a more specific verb like addressing, treating, solving, mitigating (unless handling errors or exceptions)
  (matched 'handling' in /Users/benjamin/.style-check.d/verbose-phrases:109)
<table id="bef82f4f1918bc044e89546fee5a244b0bd91d00" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 432
, column: 551
)<div class="x"><button onclick="myFunction('bef82f4f1918bc044e89546fee5a244b0bd91d00');">X</button></div></td></tr>
<tr><th>Original</th><td>Given the critical nature of the central quorum, a natural question arises: can the quorum scale to meet the availability needs of the Federated system as the topology grows? At a minimum, members of the quorum must be distributed geographically to provide high availability to anti-entropy synchronization requests, requiring at least one quorum node per location. As topologies scale, not only do the number of devices making requests to the leader increase, but so to do the number of objects that must be managed. Finally, as previously shown in Figure \ref{fig:scaling_visible_writes} the number of clients making requests increases, the overall visibility of new versions decreases unacceptably. Larger quorums provide more availability but additional resource requirements.</td></tr>
<tr><th>Problem</th><td>Figure \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="4a653a95db97f1de571c1d37d2a2dd64dc953f47" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 435
, column: 507
)<div class="x"><button onclick="myFunction('4a653a95db97f1de571c1d37d2a2dd64dc953f47');">X</button></div></td></tr>
<tr><th>Original</th><td>Raft and Paxos optimize the three phase consensus procedure (propose, accept, commit) of quorums by nominating a dedicated proposer, often called the leader or coordinator, who is solely allowed to make voting proposals thus staging the propose phase in advance of any consensus decisions via election. However, the leader is also a single point of failure, and most work in consensus protocols regards correctness and fault tolerance of a system given partitions that remove the leader from connecting to a majority of nodes. Additionally, in order to achieve linearizablity, every single access (including reads) must go through the leader, making the leader a bottleneck whose response performance creates a floor for the overall performance of the system. In order to scale consensus to larger systems, leadership must be addressed.</td></tr>
<tr><th>Problem</th><td>a majority of</td></tr>
<tr><th>Solution</th><td>phrase "most", though 'a majority of' implies more than 50  </td></tr>
<tr><th>Trigger</th><td> 'a majority of' in /Users/benjamin/.style-check.d/day-gastel:6</td></tr>
</table>
 phrase "most", though 'a majority of' implies more than 50  (matched 'a majority of' in /Users/benjamin/.style-check.d/day-gastel:6)
<table id="3c8bf386c1b5180e6a8238fede9be442c5e0c866" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 435
, column: 542
)<div class="x"><button onclick="myFunction('3c8bf386c1b5180e6a8238fede9be442c5e0c866');">X</button></div></td></tr>
<tr><th>Original</th><td>Raft and Paxos optimize the three phase consensus procedure (propose, accept, commit) of quorums by nominating a dedicated proposer, often called the leader or coordinator, who is solely allowed to make voting proposals thus staging the propose phase in advance of any consensus decisions via election. However, the leader is also a single point of failure, and most work in consensus protocols regards correctness and fault tolerance of a system given partitions that remove the leader from connecting to a majority of nodes. Additionally, in order to achieve linearizablity, every single access (including reads) must go through the leader, making the leader a bottleneck whose response performance creates a floor for the overall performance of the system. In order to scale consensus to larger systems, leadership must be addressed.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="ef670d81a109acaf2d693622bd3cd46feead002a" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 435
, column: 509
)<div class="x"><button onclick="myFunction('ef670d81a109acaf2d693622bd3cd46feead002a');">X</button></div></td></tr>
<tr><th>Original</th><td>Raft and Paxos optimize the three phase consensus procedure (propose, accept, commit) of quorums by nominating a dedicated proposer, often called the leader or coordinator, who is solely allowed to make voting proposals thus staging the propose phase in advance of any consensus decisions via election. However, the leader is also a single point of failure, and most work in consensus protocols regards correctness and fault tolerance of a system given partitions that remove the leader from connecting to a majority of nodes. Additionally, in order to achieve linearizablity, every single access (including reads) must go through the leader, making the leader a bottleneck whose response performance creates a floor for the overall performance of the system. In order to scale consensus to larger systems, leadership must be addressed.</td></tr>
<tr><th>Problem</th><td>majority of</td></tr>
<tr><th>Solution</th><td>phrase "most"
  </td></tr>
<tr><th>Trigger</th><td> 'majority of' in /Users/benjamin/.style-check.d/day-gastel:133</td></tr>
</table>
 phrase "most"
  (matched 'majority of' in /Users/benjamin/.style-check.d/day-gastel:133)
<table id="dec442ffd3bb2a61af87149bdd14a4ae78ffb3f3" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 437
, column: 394
)<div class="x"><button onclick="myFunction('dec442ffd3bb2a61af87149bdd14a4ae78ffb3f3');">X</button></div></td></tr>
<tr><th>Original</th><td>There are two primary approaches to increasing the availability of the leader in the literature: optimistic ``paths'' and multiple leaders. The former method, implemented in Fast Paxos ~, Egalatarian Paxos ~, and S-Paxos ~ allows clients to directly contact acceptors (followers) with proposals, bypassing the leader and distributing leadership activities in a so called optimistic ``fast path''. However, in order to maintain correctness some conflict detection method is required; for example Fast Paxos requires larger quorums for fast path, and Egalitarian Paxos adds dependencies that are checked at ``execution'', where a dependency failure requires a fall back to the ``classic (slow) path''. The latter method allocates the decision space to multiple coordinators either by load balancing multiple quorums as in Multi-Paxos ~ or by utilizing a per-tablet (a grouping of objects) quorum as in BigTable ~. Per-tablet quorums also reduce the likelihood of conflicts introducing the possibility of a hybrid approach: optimistic fast paths on multiple quorums with conflict detection and slow path resolution as in MDCC ~.</td></tr>
<tr><th>Problem</th><td>''.</td></tr>
<tr><th>Solution</th><td>syntax end quotes go outside punctuation like . and ,
  </td></tr>
<tr><th>Trigger</th><td> '''[\.,]' in /Users/benjamin/.style-check.d/common-typos:4</td></tr>
</table>
 syntax end quotes go outside punctuation like . and ,
  (matched '''[\.,]' in /Users/benjamin/.style-check.d/common-typos:4)
<table id="c8c38eb7afc88a5cf38dd2f7831d5245eb8200f4" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 437
, column: 407
)<div class="x"><button onclick="myFunction('c8c38eb7afc88a5cf38dd2f7831d5245eb8200f4');">X</button></div></td></tr>
<tr><th>Original</th><td>There are two primary approaches to increasing the availability of the leader in the literature: optimistic ``paths'' and multiple leaders. The former method, implemented in Fast Paxos ~, Egalatarian Paxos ~, and S-Paxos ~ allows clients to directly contact acceptors (followers) with proposals, bypassing the leader and distributing leadership activities in a so called optimistic ``fast path''. However, in order to maintain correctness some conflict detection method is required; for example Fast Paxos requires larger quorums for fast path, and Egalitarian Paxos adds dependencies that are checked at ``execution'', where a dependency failure requires a fall back to the ``classic (slow) path''. The latter method allocates the decision space to multiple coordinators either by load balancing multiple quorums as in Multi-Paxos ~ or by utilizing a per-tablet (a grouping of objects) quorum as in BigTable ~. Per-tablet quorums also reduce the likelihood of conflicts introducing the possibility of a hybrid approach: optimistic fast paths on multiple quorums with conflict detection and slow path resolution as in MDCC ~.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="5dcc0d855c8f07abeb41d46481dc69bc473acd7d" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 437
, column: 393
)<div class="x"><button onclick="myFunction('5dcc0d855c8f07abeb41d46481dc69bc473acd7d');">X</button></div></td></tr>
<tr><th>Original</th><td>There are two primary approaches to increasing the availability of the leader in the literature: optimistic ``paths'' and multiple leaders. The former method, implemented in Fast Paxos ~, Egalatarian Paxos ~, and S-Paxos ~ allows clients to directly contact acceptors (followers) with proposals, bypassing the leader and distributing leadership activities in a so called optimistic ``fast path''. However, in order to maintain correctness some conflict detection method is required; for example Fast Paxos requires larger quorums for fast path, and Egalitarian Paxos adds dependencies that are checked at ``execution'', where a dependency failure requires a fall back to the ``classic (slow) path''. The latter method allocates the decision space to multiple coordinators either by load balancing multiple quorums as in Multi-Paxos ~ or by utilizing a per-tablet (a grouping of objects) quorum as in BigTable ~. Per-tablet quorums also reduce the likelihood of conflicts introducing the possibility of a hybrid approach: optimistic fast paths on multiple quorums with conflict detection and slow path resolution as in MDCC ~.</td></tr>
<tr><th>Problem</th><td>h''.</td></tr>
<tr><th>Solution</th><td>syntax close quotes outside the period. (doesn't seem to work.)
  </td></tr>
<tr><th>Trigger</th><td> '[a-z]''[\.]' in /Users/benjamin/.style-check.d/latex-checking:23</td></tr>
</table>
 syntax close quotes outside the period. (doesn't seem to work.)
  (matched '[a-z]''[\.]' in /Users/benjamin/.style-check.d/latex-checking:23)
<table id="4a76adf2dd9f3a6f9f430ac00dd7f784f881e6d3" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 437
, column: 1
)<div class="x"><button onclick="myFunction('4a76adf2dd9f3a6f9f430ac00dd7f784f881e6d3');">X</button></div></td></tr>
<tr><th>Original</th><td>There are two primary approaches to increasing the availability of the leader in the literature: optimistic ``paths'' and multiple leaders. The former method, implemented in Fast Paxos ~, Egalatarian Paxos ~, and S-Paxos ~ allows clients to directly contact acceptors (followers) with proposals, bypassing the leader and distributing leadership activities in a so called optimistic ``fast path''. However, in order to maintain correctness some conflict detection method is required; for example Fast Paxos requires larger quorums for fast path, and Egalitarian Paxos adds dependencies that are checked at ``execution'', where a dependency failure requires a fall back to the ``classic (slow) path''. The latter method allocates the decision space to multiple coordinators either by load balancing multiple quorums as in Multi-Paxos ~ or by utilizing a per-tablet (a grouping of objects) quorum as in BigTable ~. Per-tablet quorums also reduce the likelihood of conflicts introducing the possibility of a hybrid approach: optimistic fast paths on multiple quorums with conflict detection and slow path resolution as in MDCC ~.</td></tr>
<tr><th>Problem</th><td>There are two primary approaches to increasing the availability of the leader in</td></tr>
<tr><th>Solution</th><td>phrase maybe this is passive
  </td></tr>
<tr><th>Trigger</th><td> 'there (are|is) [^\.:;]* (that|in)' in /Users/benjamin/.style-check.d/passive-voice:5</td></tr>
</table>
 phrase maybe this is passive
  (matched 'there (are|is) [^\.:;]* (that|in)' in /Users/benjamin/.style-check.d/passive-voice:5)
<table id="cb031e29a5f86199a5affedaa20d15e3300f040a" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 439
, column: 83
)<div class="x"><button onclick="myFunction('cb031e29a5f86199a5affedaa20d15e3300f040a');">X</button></div></td></tr>
<tr><th>Original</th><td>Unfortunately these approaches, while working well on smaller scale quorum sizes (3-7 nodes), do not scale well in heterogenous and variable-latency environments. Fast-path requires optimism that conflict is relatively rare, otherwise it performs worse than simple classic-path methods since it must implement conflict detection. In larger networks, conflict is more likely, both because of the increased number of writers and owing to message delay. Allocating multiple, small quorums to different decision spaces requires that objects in different tablets be independent of each other; that is, there is no way to order writes sequentially to objects in tablets maintained by separate quorums. Federated consistency, however, requires a single, sequential ordering of all writes to maintain the eventual cloud and many applications of personal clouds that have implicit dependencies not easily embedded as application-level invariants, such as those specified database schemas.</td></tr>
<tr><th>Problem</th><td>3-7</td></tr>
<tr><th>Solution</th><td>syntax use an endash '--' for ranges
  </td></tr>
<tr><th>Trigger</th><td> '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7</td></tr>
</table>
 syntax use an endash '--' for ranges
  (matched '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7)
<table id="a3520be99ed5a2574a35c3726ae34095edfac86f" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 439
, column: 598
)<div class="x"><button onclick="myFunction('a3520be99ed5a2574a35c3726ae34095edfac86f');">X</button></div></td></tr>
<tr><th>Original</th><td>Unfortunately these approaches, while working well on smaller scale quorum sizes (3-7 nodes), do not scale well in heterogenous and variable-latency environments. Fast-path requires optimism that conflict is relatively rare, otherwise it performs worse than simple classic-path methods since it must implement conflict detection. In larger networks, conflict is more likely, both because of the increased number of writers and owing to message delay. Allocating multiple, small quorums to different decision spaces requires that objects in different tablets be independent of each other; that is, there is no way to order writes sequentially to objects in tablets maintained by separate quorums. Federated consistency, however, requires a single, sequential ordering of all writes to maintain the eventual cloud and many applications of personal clouds that have implicit dependencies not easily embedded as application-level invariants, such as those specified database schemas.</td></tr>
<tr><th>Problem</th><td>there is no way to order writes sequentially to objects in</td></tr>
<tr><th>Solution</th><td>phrase maybe this is passive
  </td></tr>
<tr><th>Trigger</th><td> 'there (are|is) [^\.:;]* (that|in)' in /Users/benjamin/.style-check.d/passive-voice:5</td></tr>
</table>
 phrase maybe this is passive
  (matched 'there (are|is) [^\.:;]* (that|in)' in /Users/benjamin/.style-check.d/passive-voice:5)
<table id="bd2b3cf04bcfda234bd6bbd318e646759452c620" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 441
, column: 816
)<div class="x"><button onclick="myFunction('bd2b3cf04bcfda234bd6bbd318e646759452c620');">X</button></div></td></tr>
<tr><th>Original</th><td>We propose Hierarchical Consensus as a solution to scaling consensus to larger networks while still maintaining a sequential ordering across all objects such that dependencies between objects are determined at runtime. Our approach uses a tiered structure of leadership where the object namespace is governed by a root quorum that partitions the namespace to smaller subquorums via consensus decisions. The set of allocation decisions creates an ordered set of epochs where each epoch defines a specific mapping of objects to subquorums. Accesses on all objects maintained by a single quorum are dependent on each other and \textit{on no other subquorum}. Every access that occurs in a single epoch is said to have \textit{happened before} every access in previous epochs; every write within a subquorum is ordered with respect to that quorum's decisions, and every write between quorums within a single epoch is said to be concurrent.</td></tr>
<tr><th>Problem</th><td>with respect to</td></tr>
<tr><th>Solution</th><td>phrase "about
  </td></tr>
<tr><th>Trigger</th><td> 'with respect to' in /Users/benjamin/.style-check.d/day-gastel:211</td></tr>
</table>
 phrase "about
  (matched 'with respect to' in /Users/benjamin/.style-check.d/day-gastel:211)
<table id="fc9009883744a346a50453de885f6d4adeae9c36" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 441
, column: 288
)<div class="x"><button onclick="myFunction('fc9009883744a346a50453de885f6d4adeae9c36');">X</button></div></td></tr>
<tr><th>Original</th><td>We propose Hierarchical Consensus as a solution to scaling consensus to larger networks while still maintaining a sequential ordering across all objects such that dependencies between objects are determined at runtime. Our approach uses a tiered structure of leadership where the object namespace is governed by a root quorum that partitions the namespace to smaller subquorums via consensus decisions. The set of allocation decisions creates an ordered set of epochs where each epoch defines a specific mapping of objects to subquorums. Accesses on all objects maintained by a single quorum are dependent on each other and \textit{on no other subquorum}. Every access that occurs in a single epoch is said to have \textit{happened before} every access in previous epochs; every write within a subquorum is ordered with respect to that quorum's decisions, and every write between quorums within a single epoch is said to be concurrent.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="026f00ee7b86cf9202e5de376c42d5d35212ed46" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 443
, column: 79
)<div class="x"><button onclick="myFunction('026f00ee7b86cf9202e5de376c42d5d35212ed46');">X</button></div></td></tr>
<tr><th>Original</th><td>Hierarchical consensus provides \textit{sequential consistency} on the entire namespace, flexibly allocating consensus decisions to object dependencies which may change over time. Hierarchical consensus is more available due to the use of multiple, smaller quorums and the localization of leadership to where accesses are occurring.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="1b092368a225f6b760756177f8beef1988901d6d" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 443
, column: 163
)<div class="x"><button onclick="myFunction('1b092368a225f6b760756177f8beef1988901d6d');">X</button></div></td></tr>
<tr><th>Original</th><td>Hierarchical consensus provides \textit{sequential consistency} on the entire namespace, flexibly allocating consensus decisions to object dependencies which may change over time. Hierarchical consensus is more available due to the use of multiple, smaller quorums and the localization of leadership to where accesses are occurring.</td></tr>
<tr><th>Problem</th><td>change over time</td></tr>
<tr><th>Solution</th><td>phrase "change"
  </td></tr>
<tr><th>Trigger</th><td> 'change over time' in /Users/benjamin/.style-check.d/verbose-phrases:192</td></tr>
</table>
 phrase "change"
  (matched 'change over time' in /Users/benjamin/.style-check.d/verbose-phrases:192)
<table id="704055d4efb8e38ee9efdb4a94f997bbda2c073e" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 448
, column: 1
)<div class="x"><button onclick="myFunction('704055d4efb8e38ee9efdb4a94f997bbda2c073e');">X</button></div></td></tr>
<tr><th>Original</th><td>In order to implement a sequentially consistent file system with consensus, we must translate the generalized consensus model to a specific consistency model. Generalized consensus protocols do not natively implement any particular consistency and only consider the application of ordered commands to a state machine. Commands generally have no dependencies and agreement considers no invariants beyond whether or not accepting the command would violate global ordering. Therefore to describe the use of a consensus protocol for consistency we must describe approaches such that a consensus decision maintains a consistency invariant. The most obvious is to use consensus to grant locks to replica, object pairs and unlocks once the write has been fully replicated. So long as read/write locks are observed, this system implements linearizeability and is equivalent to two phase commit, though such a system suffers from extremely poor performance.</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="aff69e579291aae14674d21e1880fa3d5b50216d" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 450
, column: 298
)<div class="x"><button onclick="myFunction('aff69e579291aae14674d21e1880fa3d5b50216d');">X</button></div></td></tr>
<tr><th>Original</th><td>The approach we take is to make accesses the commands, such that the state machine becomes an ordered series of accesses. If both read and write accesses are applied to the log (meaning that both a read and a write must be remote through the leader) then the system remains linearizable. However, in order to improve performance, we allow reads to occur to the local log of each follower, introducing the possibility of a fork if the local read is behind the global state and a write is submitted that modifies the stale read. Forks are the natural consequence of conflicting accesses and while exacerbated by staleness, are a product of versioning in a file system; local caching only makes the problem slightly worse. In order to maintain the no-forks invariant, leaders must therefore check writes to detect forks and drop those that are.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="075dc5c78a561eb0fd950c5c9e29aff2c759ee0c" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 459
, column: 38
)<div class="x"><button onclick="myFunction('075dc5c78a561eb0fd950c5c9e29aff2c759ee0c');">X</button></div></td></tr>
<tr><th>Original</th><td>Consider the simple example shown in Figure \ref{fig:ordered}, implemented using the Raft protocol where writes are aggregated in \texttt{AppendEntries} (shown as green lines that occur routinely every heartbeat interval). In this example the object namespace is the set $\{A, B, C\}$ and each version is represented as the object name dot annotated with a monotonically increasing version number (we presume that version 1 of each object has already been written to the log). A write is conducted by reading the latest version of the object and writing the new version, therefore a write by replica $i$ that reads version $n$ and writes to version $m$ on object $O$ is given as follows: $W_i(O.n \rightarrowtail O.m)$.   Writes are ordered with respect to their arrival at the leader ($R_j$), are appended to the logs of the followers on \texttt{AppendEntries}, are committed by the leader when a majority of followers responds affirmative to the append RPC, and are marked as committed by followers on the subsequent \texttt{AppendEntries}. The leader must reject $W_i(B.2 \rightarrowtail B.4)$ in order to maintain consistency because that write would cause a fork to occur in the log. The final log is identically ordered on all replicas for all objects, therefore we can say we have achieved sequential consistency such that every write that appears in log position $i$ happens before ($\rightarrow$) the log entry at $i-1$.</td></tr>
<tr><th>Problem</th><td>Figure \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="2c1fa6f1d55559b5d4ded12780b724d688bf329e" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 459
, column: 214
)<div class="x"><button onclick="myFunction('2c1fa6f1d55559b5d4ded12780b724d688bf329e');">X</button></div></td></tr>
<tr><th>Original</th><td>Consider the simple example shown in Figure ~, implemented using the Raft protocol where writes are aggregated in ~ (shown as green lines that occur routinely every heartbeat interval). In this example the object namespace is the set~.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="ec2f66754143bb7b6b64bb858c84f7e88efe5f29" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 463
, column: 331
)<div class="x"><button onclick="myFunction('ec2f66754143bb7b6b64bb858c84f7e88efe5f29');">X</button></div></td></tr>
<tr><th>Original</th><td>While implicit dependencies are critical to consistency, we observe that it is unlikely that a write is truly dependent on every historical write but is rather dependent on a local, recent subset of the namespace ~. Hierarchical consensus therefore makes use of \textit{explicit} causality to allocate the namespace to subquorums in order to balance the leader workload. This has several implications including allowing the ability to lock the ownership of a series of critical files, to specify particular replicas as stable storage for high value data, or to maintain policies and invariants that go beyond ordering; for example spatial polices (what data gets stored), temporal policies (what versions are stored) and synchronization policies (how and when replication occurs).</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="48aab91df4b35fe21231e0da0924561a3f496734" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 463
, column: 204
)<div class="x"><button onclick="myFunction('48aab91df4b35fe21231e0da0924561a3f496734');">X</button></div></td></tr>
<tr><th>Original</th><td>While implicit dependencies are critical to consistency, we observe that it is unlikely that a write is truly dependent on every historical write but is rather dependent on a local, recent subset of the namespace ~. Hierarchical consensus therefore makes use of \textit{explicit} causality to allocate the namespace to subquorums in order to balance the leader workload. This has several implications including allowing the ability to lock the ownership of a series of critical files, to specify particular replicas as stable storage for high value data, or to maintain policies and invariants that go beyond ordering; for example spatial polices (what data gets stored), temporal policies (what versions are stored) and synchronization policies (how and when replication occurs).</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="1244b5548f536ce757e6b587012e5e558a023e65" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 463
, column: 58
)<div class="x"><button onclick="myFunction('1244b5548f536ce757e6b587012e5e558a023e65');">X</button></div></td></tr>
<tr><th>Original</th><td>While implicit dependencies are critical to consistency, we observe that it is unlikely that a write is truly dependent on every historical write but is rather dependent on a local, recent subset of the namespace ~. Hierarchical consensus therefore makes use of \textit{explicit} causality to allocate the namespace to subquorums in order to balance the leader workload. This has several implications including allowing the ability to lock the ownership of a series of critical files, to specify particular replicas as stable storage for high value data, or to maintain policies and invariants that go beyond ordering; for example spatial polices (what data gets stored), temporal policies (what versions are stored) and synchronization policies (how and when replication occurs).</td></tr>
<tr><th>Problem</th><td>we observe that</td></tr>
<tr><th>Solution</th><td>phrase drop.
  </td></tr>
<tr><th>Trigger</th><td> 'We observe that' in /Users/benjamin/.style-check.d/verbose-phrases:111</td></tr>
</table>
 phrase drop.
  (matched 'We observe that' in /Users/benjamin/.style-check.d/verbose-phrases:111)
<table id="bf088fff90a210b194fe1326030a9289ed3c40c2" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 463
, column: 489
)<div class="x"><button onclick="myFunction('bf088fff90a210b194fe1326030a9289ed3c40c2');">X</button></div></td></tr>
<tr><th>Original</th><td>While implicit dependencies are critical to consistency, we observe that it is unlikely that a write is truly dependent on every historical write but is rather dependent on a local, recent subset of the namespace ~. Hierarchical consensus therefore makes use of \textit{explicit} causality to allocate the namespace to subquorums in order to balance the leader workload. This has several implications including allowing the ability to lock the ownership of a series of critical files, to specify particular replicas as stable storage for high value data, or to maintain policies and invariants that go beyond ordering; for example spatial polices (what data gets stored), temporal policies (what versions are stored) and synchronization policies (how and when replication occurs).</td></tr>
<tr><th>Problem</th><td>specify particular</td></tr>
<tr><th>Solution</th><td>phrase if specifying, particular should be redundant.
  </td></tr>
<tr><th>Trigger</th><td> 'specify particular' in /Users/benjamin/.style-check.d/verbose-phrases:173</td></tr>
</table>
 phrase if specifying, particular should be redundant.
  (matched 'specify particular' in /Users/benjamin/.style-check.d/verbose-phrases:173)
<table id="b8112958cdd33369bf2f9cfeacb505d29714632c" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 465
, column: 16
)<div class="x"><button onclick="myFunction('b8112958cdd33369bf2f9cfeacb505d29714632c');">X</button></div></td></tr>
<tr><th>Original</th><td>\subsubsection{Namespace Allocation}</td></tr>
<tr><th>Problem</th><td>Namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="996a64311e1a4196bb1c21ec4f72a70384cc0520" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 471
, column: 56
)<div class="x"><button onclick="myFunction('996a64311e1a4196bb1c21ec4f72a70384cc0520');">X</button></div></td></tr>
<tr><th>Original</th><td>        \caption{Hierarchical consensus partitions the namespace across subquorums}</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="f69fd856347ea46695911e69262d8f22c4b11ec6" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 475
, column: 290
)<div class="x"><button onclick="myFunction('f69fd856347ea46695911e69262d8f22c4b11ec6');">X</button></div></td></tr>
<tr><th>Original</th><td>An open question for our research is how to automatically allocate the namespace such that leadership of a subset of the namespace is local to the accesses and that members of the quorum are distributed to provide wide area durability and availability. The goal of allocation, is shown in Figure \ref{fig:hierarchical} - a hierarchy of quorums such that the children of each tier manage consensus decisions on a non-overlapping portion of the namespace.</td></tr>
<tr><th>Problem</th><td>Figure \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="9016d524a6e8723bec750529cc66fe43b746a482" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 475
, column: 298
)<div class="x"><button onclick="myFunction('9016d524a6e8723bec750529cc66fe43b746a482');">X</button></div></td></tr>
<tr><th>Original</th><td>An open question for our research is how to automatically allocate the namespace such that leadership of a subset of the namespace is local to the accesses and that members of the quorum are distributed to provide wide area durability and availability. The goal of allocation, is shown in Figure ~ - a hierarchy of quorums such that the children of each tier manage consensus decisions on a non-overlapping portion of the namespace.</td></tr>
<tr><th>Problem</th><td> - </td></tr>
<tr><th>Solution</th><td>syntax a hyphen surrounded by space should probably be an emdash '---'
  </td></tr>
<tr><th>Trigger</th><td> '[ ]-[ ]' in /Users/benjamin/.style-check.d/common-typos:6</td></tr>
</table>
 syntax a hyphen surrounded by space should probably be an emdash '---'
  (matched '[ ]-[ ]' in /Users/benjamin/.style-check.d/common-typos:6)
<table id="4369ce65456486551a4d875a4034773bea01557d" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 475
, column: 72
)<div class="x"><button onclick="myFunction('4369ce65456486551a4d875a4034773bea01557d');">X</button></div></td></tr>
<tr><th>Original</th><td>An open question for our research is how to automatically allocate the namespace such that leadership of a subset of the namespace is local to the accesses and that members of the quorum are distributed to provide wide area durability and availability. The goal of allocation, is shown in Figure ~ - a hierarchy of quorums such that the children of each tier manage consensus decisions on a non-overlapping portion of the namespace.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="69e9a3a6781143e9ed124845d6571cb255cfaa09" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 475
, column: 278
)<div class="x"><button onclick="myFunction('69e9a3a6781143e9ed124845d6571cb255cfaa09');">X</button></div></td></tr>
<tr><th>Original</th><td>An open question for our research is how to automatically allocate the namespace such that leadership of a subset of the namespace is local to the accesses and that members of the quorum are distributed to provide wide area durability and availability. The goal of allocation, is shown in Figure ~ - a hierarchy of quorums such that the children of each tier manage consensus decisions on a non-overlapping portion of the namespace.</td></tr>
<tr><th>Problem</th><td>is shown</td></tr>
<tr><th>Solution</th><td>phrase passive.
  </td></tr>
<tr><th>Trigger</th><td> 'is shown' in /Users/benjamin/.style-check.d/passive-voice:3</td></tr>
</table>
 phrase passive.
  (matched 'is shown' in /Users/benjamin/.style-check.d/passive-voice:3)
<table id="cc67b04a5ffe11ac452a91fde576678a79bf5e1e" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 475
, column: 278
)<div class="x"><button onclick="myFunction('cc67b04a5ffe11ac452a91fde576678a79bf5e1e');">X</button></div></td></tr>
<tr><th>Original</th><td>An open question for our research is how to automatically allocate the namespace such that leadership of a subset of the namespace is local to the accesses and that members of the quorum are distributed to provide wide area durability and availability. The goal of allocation, is shown in Figure ~ - a hierarchy of quorums such that the children of each tier manage consensus decisions on a non-overlapping portion of the namespace.</td></tr>
<tr><th>Problem</th><td>is shown in</td></tr>
<tr><th>Solution</th><td>phrase "shows"
  </td></tr>
<tr><th>Trigger</th><td> '(is|are) shown in' in /Users/benjamin/.style-check.d/passive-voice:14</td></tr>
</table>
 phrase "shows"
  (matched '(is|are) shown in' in /Users/benjamin/.style-check.d/passive-voice:14)
<table id="0e4ffdc63e7b0a5c5e9b09f46a2a00b3343c578a" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 477
, column: 41
)<div class="x"><button onclick="myFunction('0e4ffdc63e7b0a5c5e9b09f46a2a00b3343c578a');">X</button></div></td></tr>
<tr><th>Original</th><td>Consider a motivating example using the notion of \textit{sessions}. Starting from a quiescent state (no accesses), a node or a group of nodes begins reading and writing to a set of objects (perhaps collaborative editing of a document, or a series of financial transactions); we expect that after some finite amount of time, the access pattern will change or cease. We can therefore state that all objects involved in a single session are explicitly causally related to each other and to no other objects in the namespace. Whether we describe sessions as a fixed, sliding window or as something more variable, some automatic determination that those objects should be coordinated together is necessary. To that end we will define a \textit{tag} as a time-annotated subset of the namespace and a \textit{tagspace} as the set of non-overlapping tags that compose the namespace for a given time period.</td></tr>
<tr><th>Problem</th><td>notion</td></tr>
<tr><th>Solution</th><td>phrase avoid this weak phrase. (thanks brian bershad!)
  </td></tr>
<tr><th>Trigger</th><td> 'notion' in /Users/benjamin/.style-check.d/bad-words:21</td></tr>
</table>
 phrase avoid this weak phrase. (thanks brian bershad!)
  (matched 'notion' in /Users/benjamin/.style-check.d/bad-words:21)
<table id="8d602fba693b9e0f9055a2c34dfb2c296038a631" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 477
, column: 460
)<div class="x"><button onclick="myFunction('8d602fba693b9e0f9055a2c34dfb2c296038a631');">X</button></div></td></tr>
<tr><th>Original</th><td>Consider a motivating example using the notion of \textit{sessions}. Starting from a quiescent state (no accesses), a node or a group of nodes begins reading and writing to a set of objects (perhaps collaborative editing of a document, or a series of financial transactions); we expect that after some finite amount of time, the access pattern will change or cease. We can therefore state that all objects involved in a single session are explicitly causally related to each other and to no other objects in the namespace. Whether we describe sessions as a fixed, sliding window or as something more variable, some automatic determination that those objects should be coordinated together is necessary. To that end we will define a \textit{tag} as a time-annotated subset of the namespace and a \textit{tagspace} as the set of non-overlapping tags that compose the namespace for a given time period.</td></tr>
<tr><th>Problem</th><td>related to each other</td></tr>
<tr><th>Solution</th><td>phrase related
  </td></tr>
<tr><th>Trigger</th><td> 'related to each other' in /Users/benjamin/.style-check.d/barrass:51</td></tr>
</table>
 phrase related
  (matched 'related to each other' in /Users/benjamin/.style-check.d/barrass:51)
<table id="f616d53248b46fbb4f1a5fa9a4a28ed7cb0dd78b" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 477
, column: 513
)<div class="x"><button onclick="myFunction('f616d53248b46fbb4f1a5fa9a4a28ed7cb0dd78b');">X</button></div></td></tr>
<tr><th>Original</th><td>Consider a motivating example using the notion of \textit{sessions}. Starting from a quiescent state (no accesses), a node or a group of nodes begins reading and writing to a set of objects (perhaps collaborative editing of a document, or a series of financial transactions); we expect that after some finite amount of time, the access pattern will change or cease. We can therefore state that all objects involved in a single session are explicitly causally related to each other and to no other objects in the namespace. Whether we describe sessions as a fixed, sliding window or as something more variable, some automatic determination that those objects should be coordinated together is necessary. To that end we will define a \textit{tag} as a time-annotated subset of the namespace and a \textit{tagspace} as the set of non-overlapping tags that compose the namespace for a given time period.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="cf4847411c43c1af125aceca51aa122feee90329" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 477
, column: 586
)<div class="x"><button onclick="myFunction('cf4847411c43c1af125aceca51aa122feee90329');">X</button></div></td></tr>
<tr><th>Original</th><td>Consider a motivating example using the notion of \textit{sessions}. Starting from a quiescent state (no accesses), a node or a group of nodes begins reading and writing to a set of objects (perhaps collaborative editing of a document, or a series of financial transactions); we expect that after some finite amount of time, the access pattern will change or cease. We can therefore state that all objects involved in a single session are explicitly causally related to each other and to no other objects in the namespace. Whether we describe sessions as a fixed, sliding window or as something more variable, some automatic determination that those objects should be coordinated together is necessary. To that end we will define a \textit{tag} as a time-annotated subset of the namespace and a \textit{tagspace} as the set of non-overlapping tags that compose the namespace for a given time period.</td></tr>
<tr><th>Problem</th><td>something</td></tr>
<tr><th>Solution</th><td>phrase could eliminate.
  </td></tr>
<tr><th>Trigger</th><td> 'something' in /Users/benjamin/.style-check.d/verbose-phrases:168</td></tr>
</table>
 phrase could eliminate.
  (matched 'something' in /Users/benjamin/.style-check.d/verbose-phrases:168)
<table id="be86f125277d520dd7582fbc667f0baed55329d4" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 477
, column: 310
)<div class="x"><button onclick="myFunction('be86f125277d520dd7582fbc667f0baed55329d4');">X</button></div></td></tr>
<tr><th>Original</th><td>Consider a motivating example using the notion of \textit{sessions}. Starting from a quiescent state (no accesses), a node or a group of nodes begins reading and writing to a set of objects (perhaps collaborative editing of a document, or a series of financial transactions); we expect that after some finite amount of time, the access pattern will change or cease. We can therefore state that all objects involved in a single session are explicitly causally related to each other and to no other objects in the namespace. Whether we describe sessions as a fixed, sliding window or as something more variable, some automatic determination that those objects should be coordinated together is necessary. To that end we will define a \textit{tag} as a time-annotated subset of the namespace and a \textit{tagspace} as the set of non-overlapping tags that compose the namespace for a given time period.</td></tr>
<tr><th>Problem</th><td>amount of time</td></tr>
<tr><th>Solution</th><td>phrase "duration"
  </td></tr>
<tr><th>Trigger</th><td> 'amount of time' in /Users/benjamin/.style-check.d/verbose-phrases:209</td></tr>
</table>
 phrase "duration"
  (matched 'amount of time' in /Users/benjamin/.style-check.d/verbose-phrases:209)
<table id="1e08906e0fe62024940ec110a6ce29ab64b3df6b" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 479
, column: 95
)<div class="x"><button onclick="myFunction('1e08906e0fe62024940ec110a6ce29ab64b3df6b');">X</button></div></td></tr>
<tr><th>Original</th><td>Hierarchical consensus starts with a root quorum whose responsibility is to govern the entire namespace. The root quorum does so by maintaining a root \textit{epoch}, a monotonically increasing counter which identifies the current \textit{tagspace}. In addition to consensus decisions related to leader election, accesses, and membership changes, decisions that modify the tagspace also require consensus. We define two primary operations: \textit{split} creates a new subquorum, splitting a larger tag from the previous tagspace and \textit{join} removes a subquorum, joining two smaller tags from the previous tagspace. Any decision that modifies the tagspace (thus creating a new tagspace) requires an increment of the \textit{epoch}.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="0e19b581c8c245dd564c6dfe2ad27fb457c7e738" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 493
, column: 5
)<div class="x"><button onclick="myFunction('0e19b581c8c245dd564c6dfe2ad27fb457c7e738');">X</button></div></td></tr>
<tr><th>Original</th><td>The namespace allocation creates a tiered structure of leadership such that the root quorum is responsible for the entire namespace, subquorums are responsible for tags, and leaves are responsible for handling accesses to their tag. Any access to an object must be forwarded as a remote access to the leader of the quorum that handles the tag that encapsulates the object. The only exception is the optimization made for members of the quorum who can read locally any object in their tag space. By optimizing the locality of access and spreading the workload to multiple leaders, we hope to show that the overall performance of the system increases.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="16aa3cd2fb5ed88e9bba8c759856611f26e3cb73" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 493
, column: 202
)<div class="x"><button onclick="myFunction('16aa3cd2fb5ed88e9bba8c759856611f26e3cb73');">X</button></div></td></tr>
<tr><th>Original</th><td>The namespace allocation creates a tiered structure of leadership such that the root quorum is responsible for the entire namespace, subquorums are responsible for tags, and leaves are responsible for handling accesses to their tag. Any access to an object must be forwarded as a remote access to the leader of the quorum that handles the tag that encapsulates the object. The only exception is the optimization made for members of the quorum who can read locally any object in their tag space. By optimizing the locality of access and spreading the workload to multiple leaders, we hope to show that the overall performance of the system increases.</td></tr>
<tr><th>Problem</th><td>handling</td></tr>
<tr><th>Solution</th><td>phrase use a more specific verb like addressing, treating, solving, mitigating (unless handling errors or exceptions)
  </td></tr>
<tr><th>Trigger</th><td> 'handling' in /Users/benjamin/.style-check.d/verbose-phrases:109</td></tr>
</table>
 phrase use a more specific verb like addressing, treating, solving, mitigating (unless handling errors or exceptions)
  (matched 'handling' in /Users/benjamin/.style-check.d/verbose-phrases:109)
<table id="ce19063710f7ae03a18ed6cd7a27593100d045d1" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 497
, column: 301
)<div class="x"><button onclick="myFunction('ce19063710f7ae03a18ed6cd7a27593100d045d1');">X</button></div></td></tr>
<tr><th>Original</th><td>The issue is that a remote access from one tag to another creates an implicit dependency between all accesses that happened before the remote access and all those that follow the local one. Correctness is maintained by the ordering of epochs, so some local split is required. Consider the example in Figure \ref{fig:subepoch}: the remote read access, $R_j(C)$ implies any writes to tag $D-F$ following the read depends an all writes in tag $A-C$ that occurred before the read. Furthermore, the remote write $W_j(C.3 \rightarrowtail C.4)$ is a non-conflicting write, depends on all writes on tag $D-F$ that happened before \textit{and} depends on all writes in tag $A-C$ that occurred before the remote read, and occurs concurrently with any writes that happen after so long as there is no conflict.</td></tr>
<tr><th>Problem</th><td>Figure \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="cb6370139ed6252e6831f0491a20cbbb7c6f7311" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 499
, column: 23
)<div class="x"><button onclick="myFunction('cb6370139ed6252e6831f0491a20cbbb7c6f7311');">X</button></div></td></tr>
<tr><th>Original</th><td>Our proposed solution is similar to the epoch solution: each tag quorum maintains a per-epoch, monotonically increasing sub-epoch counter. In the case of a remote access, that counter is incremented to demarcate the ordering of all accesses in the tag that happened before the remote access and all those that follow. This counter must be replicated in addition to the version number, and can therefore be seen as an explicit dependency applied to all remote writes. As a result, any quorum that receives these ordering indicators can appropriately order their logs.</td></tr>
<tr><th>Problem</th><td>is similar to</td></tr>
<tr><th>Solution</th><td>phrase "resembles"
  </td></tr>
<tr><th>Trigger</th><td> 'is similar to' in /Users/benjamin/.style-check.d/day-gastel:111</td></tr>
</table>
 phrase "resembles"
  (matched 'is similar to' in /Users/benjamin/.style-check.d/day-gastel:111)
<table id="470ec75e86a9c5739d77378078b76749d001f298" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 501
, column: 146
)<div class="x"><button onclick="myFunction('470ec75e86a9c5739d77378078b76749d001f298');">X</button></div></td></tr>
<tr><th>Original</th><td>This mechanism also leads us to suspect that generalizing the consensus hierarchy to arbitrarily deep levels is possible; particularly since the notion of sub-epoch numbers already exists. Clearly some coordination is required to ensure that tag space changes filter down to all leaf nodes, and that is the primary subject of our future work related to this proposal.</td></tr>
<tr><th>Problem</th><td>notion</td></tr>
<tr><th>Solution</th><td>phrase avoid this weak phrase. (thanks brian bershad!)
  </td></tr>
<tr><th>Trigger</th><td> 'notion' in /Users/benjamin/.style-check.d/bad-words:21</td></tr>
</table>
 phrase avoid this weak phrase. (thanks brian bershad!)
  (matched 'notion' in /Users/benjamin/.style-check.d/bad-words:21)
<table id="ba045931c03ea64e0a6f24ca322dba7cb23dac6c" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 503
, column: 74
)<div class="x"><button onclick="myFunction('ba045931c03ea64e0a6f24ca322dba7cb23dac6c');">X</button></div></td></tr>
<tr><th>Original</th><td>In addition to correctness, we also propose to show failure tolerance by utilize Raft-style quorum mechanics. There are two distinct kinds of failure in a hierarchical system: replica failures (a single node crashes and dies) and partitions, where parts of the network are cut off from receiving messages. We believe that we can model failure tolerance from both of these perspectives through a formulation of quorum size, minimal intersection set between quorums, and the depth/breadth of the hierarchy. We propose to show correctness in the face of failure in the least and will stretch to show inherent robustness due to the structure of the hierarchy.</td></tr>
<tr><th>Problem</th><td>utilize</td></tr>
<tr><th>Solution</th><td>phrase "use"
  </td></tr>
<tr><th>Trigger</th><td> 'utilize' in /Users/benjamin/.style-check.d/day-gastel:200</td></tr>
</table>
 phrase "use"
  (matched 'utilize' in /Users/benjamin/.style-check.d/day-gastel:200)
<table id="3d7c1653ca083253a87a40d8c68c657711d399ce" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 503
, column: 111
)<div class="x"><button onclick="myFunction('3d7c1653ca083253a87a40d8c68c657711d399ce');">X</button></div></td></tr>
<tr><th>Original</th><td>In addition to correctness, we also propose to show failure tolerance by utilize Raft-style quorum mechanics. There are two distinct kinds of failure in a hierarchical system: replica failures (a single node crashes and dies) and partitions, where parts of the network are cut off from receiving messages. We believe that we can model failure tolerance from both of these perspectives through a formulation of quorum size, minimal intersection set between quorums, and the depth/breadth of the hierarchy. We propose to show correctness in the face of failure in the least and will stretch to show inherent robustness due to the structure of the hierarchy.</td></tr>
<tr><th>Problem</th><td>There are two distinct kinds of failure in</td></tr>
<tr><th>Solution</th><td>phrase maybe this is passive
  </td></tr>
<tr><th>Trigger</th><td> 'there (are|is) [^\.:;]* (that|in)' in /Users/benjamin/.style-check.d/passive-voice:5</td></tr>
</table>
 phrase maybe this is passive
  (matched 'there (are|is) [^\.:;]* (that|in)' in /Users/benjamin/.style-check.d/passive-voice:5)
<table id="11650db809e415fe96e34ac22193b5601c35eb91" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 503
, column: 537
)<div class="x"><button onclick="myFunction('11650db809e415fe96e34ac22193b5601c35eb91');">X</button></div></td></tr>
<tr><th>Original</th><td>In addition to correctness, we also propose to show failure tolerance by utilize Raft-style quorum mechanics. There are two distinct kinds of failure in a hierarchical system: replica failures (a single node crashes and dies) and partitions, where parts of the network are cut off from receiving messages. We believe that we can model failure tolerance from both of these perspectives through a formulation of quorum size, minimal intersection set between quorums, and the depth/breadth of the hierarchy. We propose to show correctness in the face of failure in the least and will stretch to show inherent robustness due to the structure of the hierarchy.</td></tr>
<tr><th>Problem</th><td>in the face of</td></tr>
<tr><th>Solution</th><td>phrase can be overused.  try despite?
  </td></tr>
<tr><th>Trigger</th><td> 'in the face of' in /Users/benjamin/.style-check.d/verbose-phrases:84</td></tr>
</table>
 phrase can be overused.  try despite?
  (matched 'in the face of' in /Users/benjamin/.style-check.d/verbose-phrases:84)
<table id="ae4008310a0a7278bab2e39404db0fc24149977f" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 508
, column: 612
)<div class="x"><button onclick="myFunction('ae4008310a0a7278bab2e39404db0fc24149977f');">X</button></div></td></tr>
<tr><th>Original</th><td>Experimentation by simulation is essential to give us the flexibility to describe a wide variety of environments, parameters, and use-cases. However we propose to implement a distributed file system called FlowFS to more completely explore the use of Federated Consistency and Hierarchical Consensus. FlowFS, implemented in the Go programming language, will allow us to quantitatively describe real-world environments and utilization and to show how our proposed consistency model is experienced by users. In this section we will describe our proposed implementation, described by the component architecture in Figure \ref{fig:architecture}.</td></tr>
<tr><th>Problem</th><td>Figure \ref</td></tr>
<tr><th>Solution</th><td>syntax Table, Figure, and Section refs should have a non-breaking space</td></tr>
</table>
 syntax Table, Figure, and Section refs should have a non-breaking space
<table id="b1809b750ccc56d1d95a4c68715ed40636ab63aa" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 508
, column: 423
)<div class="x"><button onclick="myFunction('b1809b750ccc56d1d95a4c68715ed40636ab63aa');">X</button></div></td></tr>
<tr><th>Original</th><td>Experimentation by simulation is essential to give us the flexibility to describe a wide variety of environments, parameters, and use-cases. However we propose to implement a distributed file system called FlowFS to more completely explore the use of Federated Consistency and Hierarchical Consensus. FlowFS, implemented in the Go programming language, will allow us to quantitatively describe real-world environments and utilization and to show how our proposed consistency model is experienced by users. In this section we will describe our proposed implementation, described by the component architecture in Figure ~.</td></tr>
<tr><th>Problem</th><td>utilization</td></tr>
<tr><th>Solution</th><td>phrase "use"
  </td></tr>
<tr><th>Trigger</th><td> 'utilization' in /Users/benjamin/.style-check.d/day-gastel:199</td></tr>
</table>
 phrase "use"
  (matched 'utilization' in /Users/benjamin/.style-check.d/day-gastel:199)
<table id="e5ab055709b8ad36ed817ce10b83ba7898abd572" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 508
, column: 507
)<div class="x"><button onclick="myFunction('e5ab055709b8ad36ed817ce10b83ba7898abd572');">X</button></div></td></tr>
<tr><th>Original</th><td>Experimentation by simulation is essential to give us the flexibility to describe a wide variety of environments, parameters, and use-cases. However we propose to implement a distributed file system called FlowFS to more completely explore the use of Federated Consistency and Hierarchical Consensus. FlowFS, implemented in the Go programming language, will allow us to quantitatively describe real-world environments and utilization and to show how our proposed consistency model is experienced by users. In this section we will describe our proposed implementation, described by the component architecture in Figure ~.</td></tr>
<tr><th>Problem</th><td>In this section we</td></tr>
<tr><th>Solution</th><td>phrase "In this section, we", or "In this section, I"
  </td></tr>
<tr><th>Trigger</th><td> 'In this section (we|I)' in /Users/benjamin/.style-check.d/verbose-phrases:128</td></tr>
</table>
 phrase "In this section, we", or "In this section, I"
  (matched 'In this section (we|I)' in /Users/benjamin/.style-check.d/verbose-phrases:128)
<table id="02b5501b5909df412eefdd9f8a7182f57fcaa789" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 517
, column: 892
)<div class="x"><button onclick="myFunction('02b5501b5909df412eefdd9f8a7182f57fcaa789');">X</button></div></td></tr>
<tr><th>Original</th><td>FlowFS aggregates individual accesses into \textit{Close-To-Open} (CTO) consistency such that read and write accesses are ``whole file'' ~. Furthermore, with respect to local accesses we guarantee that a read returns the last write (given no remote updates, \textit{Read Your Writes Consistency}) and that writes are atomic with respect to each other (\textit{Monotonic Write Consistency}) ~. These client-oriented consistency guarantees are necessary to provide file system semantics and are enabled by local cacheing such that intermediate sync and flush operations are written to disk and replication only occurs when a file is closed. This however, does present an increased opportunity for inconsistency as the editing latency of a file increases the likelihood of concurrent accesses. Two concurrent write accesses create forks in the version history, a conflict that must be resolved in order to maintain file system consistency. However, in order to describe conflict resolution (both manual and automatic), we first must describe how objects and their versions are defined.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="7887cbd444529ef28f05c425afaaf78282d56975" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 517
, column: 154
)<div class="x"><button onclick="myFunction('7887cbd444529ef28f05c425afaaf78282d56975');">X</button></div></td></tr>
<tr><th>Original</th><td>FlowFS aggregates individual accesses into \textit{Close-To-Open} (CTO) consistency such that read and write accesses are ``whole file'' ~. Furthermore, with respect to local accesses we guarantee that a read returns the last write (given no remote updates, \textit{Read Your Writes Consistency}) and that writes are atomic with respect to each other (\textit{Monotonic Write Consistency}) ~. These client-oriented consistency guarantees are necessary to provide file system semantics and are enabled by local cacheing such that intermediate sync and flush operations are written to disk and replication only occurs when a file is closed. This however, does present an increased opportunity for inconsistency as the editing latency of a file increases the likelihood of concurrent accesses. Two concurrent write accesses create forks in the version history, a conflict that must be resolved in order to maintain file system consistency. However, in order to describe conflict resolution (both manual and automatic), we first must describe how objects and their versions are defined.</td></tr>
<tr><th>Problem</th><td>with respect to</td></tr>
<tr><th>Solution</th><td>phrase "about
  </td></tr>
<tr><th>Trigger</th><td> 'with respect to' in /Users/benjamin/.style-check.d/day-gastel:211</td></tr>
</table>
 phrase "about
  (matched 'with respect to' in /Users/benjamin/.style-check.d/day-gastel:211)
<table id="0a1cc9574bb545d8450c0cccdee608bd6a5f2910" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 519
, column: 573
)<div class="x"><button onclick="myFunction('0a1cc9574bb545d8450c0cccdee608bd6a5f2910');">X</button></div></td></tr>
<tr><th>Original</th><td>The file system is defined as a hierarchical namespace, which could be described as an object store with complex keys similar to Amazon S3 ~. Each object has a unique name which is associated with a piece of metadata called a \emph{version}. Versions are identified by a monotonically increasing version number, implemented either as a vector clock ~ (or a simple Lamport scaler) in the case of a fixed topology or as a vector stamp ~ in the case of dynamic topologies. Version numbers are utilized to provide fork detection and identify potential conflicts. Versions are related to each other with dependency information and all versions have at least one dependency: the parent version that it was derived from. As such, the namespace identifies a \emph{object history} and the most recent versions local to a replica server define the \emph{view} of the file system.</td></tr>
<tr><th>Problem</th><td>related to each other</td></tr>
<tr><th>Solution</th><td>phrase related
  </td></tr>
<tr><th>Trigger</th><td> 'related to each other' in /Users/benjamin/.style-check.d/barrass:51</td></tr>
</table>
 phrase related
  (matched 'related to each other' in /Users/benjamin/.style-check.d/barrass:51)
<table id="c18de0dc52f69eb09ab314669e37b778cc2e9d7e" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 519
, column: 17
)<div class="x"><button onclick="myFunction('c18de0dc52f69eb09ab314669e37b778cc2e9d7e');">X</button></div></td></tr>
<tr><th>Original</th><td>The file system is defined as a hierarchical namespace, which could be described as an object store with complex keys similar to Amazon S3 ~. Each object has a unique name which is associated with a piece of metadata called a \emph{version}. Versions are identified by a monotonically increasing version number, implemented either as a vector clock ~ (or a simple Lamport scaler) in the case of a fixed topology or as a vector stamp ~ in the case of dynamic topologies. Version numbers are utilized to provide fork detection and identify potential conflicts. Versions are related to each other with dependency information and all versions have at least one dependency: the parent version that it was derived from. As such, the namespace identifies a \emph{object history} and the most recent versions local to a replica server define the \emph{view} of the file system.</td></tr>
<tr><th>Problem</th><td>is defined as</td></tr>
<tr><th>Solution</th><td>phrase "is"
  </td></tr>
<tr><th>Trigger</th><td> 'is defined as' in /Users/benjamin/.style-check.d/day-gastel:108</td></tr>
</table>
 phrase "is"
  (matched 'is defined as' in /Users/benjamin/.style-check.d/day-gastel:108)
<table id="efff6b5e7e83760e82988e085bac767da6d3cc40" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 519
, column: 46
)<div class="x"><button onclick="myFunction('efff6b5e7e83760e82988e085bac767da6d3cc40');">X</button></div></td></tr>
<tr><th>Original</th><td>The file system is defined as a hierarchical namespace, which could be described as an object store with complex keys similar to Amazon S3 ~. Each object has a unique name which is associated with a piece of metadata called a \emph{version}. Versions are identified by a monotonically increasing version number, implemented either as a vector clock ~ (or a simple Lamport scaler) in the case of a fixed topology or as a vector stamp ~ in the case of dynamic topologies. Version numbers are utilized to provide fork detection and identify potential conflicts. Versions are related to each other with dependency information and all versions have at least one dependency: the parent version that it was derived from. As such, the namespace identifies a \emph{object history} and the most recent versions local to a replica server define the \emph{view} of the file system.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<table id="6f3ac20292bad0e6ad886ae4938df8afb459f90f" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 519
, column: 252
)<div class="x"><button onclick="myFunction('6f3ac20292bad0e6ad886ae4938df8afb459f90f');">X</button></div></td></tr>
<tr><th>Original</th><td>The file system is defined as a hierarchical namespace, which could be described as an object store with complex keys similar to Amazon S3 ~. Each object has a unique name which is associated with a piece of metadata called a \emph{version}. Versions are identified by a monotonically increasing version number, implemented either as a vector clock ~ (or a simple Lamport scaler) in the case of a fixed topology or as a vector stamp ~ in the case of dynamic topologies. Version numbers are utilized to provide fork detection and identify potential conflicts. Versions are related to each other with dependency information and all versions have at least one dependency: the parent version that it was derived from. As such, the namespace identifies a \emph{object history} and the most recent versions local to a replica server define the \emph{view} of the file system.</td></tr>
<tr><th>Problem</th><td>are identified by</td></tr>
<tr><th>Solution</th><td>phrase passive
  </td></tr>
<tr><th>Trigger</th><td> 'are identified by' in /Users/benjamin/.style-check.d/passive-voice:2</td></tr>
</table>
 phrase passive
  (matched 'are identified by' in /Users/benjamin/.style-check.d/passive-voice:2)
<table id="10423f2a3d59c49517ea129ccc67fdcfdbe00d90" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 521
, column: 277
)<div class="x"><button onclick="myFunction('10423f2a3d59c49517ea129ccc67fdcfdbe00d90');">X</button></div></td></tr>
<tr><th>Original</th><td>When a file is closed after editing, the data associated with the file is chunked into a series of unique, fixed-length blobs identified by a hashing function applied to the data. The version created by the write access to the file specifies the blobs and their ordering that make up the file. However because blobs are unique, we assert that consistent replication can be decoupled from blob replication. Every device in the system therefore has a complete view of the file system because all version meta data is completely replicated without the storage resource constraints of fully replicated blobs. In fact, every device can specify distinct local storage policies (object aspects) that define what blobs reside on their local disks. The protocol and timing used to replicate both versions and objects can also be modified locally to specify a message budget or other resource restrictions (synchronization aspects). Techniques like hoarding ~ and TCP layer replication ~ can improve blob replication, optimistically colocating blobs with likely read accesses. However, if a blob is not available locally a remote access to a storage device with the blob is all that is required.</td></tr>
<tr><th>Problem</th><td>make up</td></tr>
<tr><th>Solution</th><td>phrase "constitute" "compose"
  </td></tr>
<tr><th>Trigger</th><td> 'make up' in /Users/benjamin/.style-check.d/verbose-phrases:139</td></tr>
</table>
 phrase "constitute" "compose"
  (matched 'make up' in /Users/benjamin/.style-check.d/verbose-phrases:139)
<table id="96972dc5f31f00b1361407dac277a07631e7f0cc" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 523
, column: 115
)<div class="x"><button onclick="myFunction('96972dc5f31f00b1361407dac277a07631e7f0cc');">X</button></div></td></tr>
<tr><th>Original</th><td>Decoupling blobs from versions also provides a unique conflict detection and resolution mechanism that can reduce the impact of the increased likelihood of concurrent access due to CTO consistency. Similar to Git and OriFS ~ version trees can be implemented with data structures that perform deeper conflict detection down to the blob level. If two different blobs have been modified, automatic conflict resolution can be applied similar to Git merge. If the same blobs have been modified a manual intervention is required; on close, a diff can immediately be shown to the user so that conflicts are handled close to the time that they occur. This mechanism works best for files that are edited in multiple locations, such as documents, and poorly for files that are completely modified no matter the size of the change, such as binary files. We assert that binary files, primarily images, video, binary executables, etc. are generally created once and updated rarely and therefore generally have a low likelihood of conflict, requiring no special conflict resolution mechanism.</td></tr>
<tr><th>Problem</th><td>the impact</td></tr>
<tr><th>Solution</th><td>phrase "consequences", "effect", "result", though nsf likes "research impact"
  </td></tr>
<tr><th>Trigger</th><td> '[^r][^c][^h] impact' in /Users/benjamin/.style-check.d/bad-words:10</td></tr>
</table>
 phrase "consequences", "effect", "result", though nsf likes "research impact"
  (matched '[^r][^c][^h] impact' in /Users/benjamin/.style-check.d/bad-words:10)
<table id="634979609f5c84fa1b197d0a2a061d8937c7c643" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 523
, column: 920
)<div class="x"><button onclick="myFunction('634979609f5c84fa1b197d0a2a061d8937c7c643');">X</button></div></td></tr>
<tr><th>Original</th><td>Decoupling blobs from versions also provides a unique conflict detection and resolution mechanism that can reduce the impact of the increased likelihood of concurrent access due to CTO consistency. Similar to Git and OriFS ~ version trees can be implemented with data structures that perform deeper conflict detection down to the blob level. If two different blobs have been modified, automatic conflict resolution can be applied similar to Git merge. If the same blobs have been modified a manual intervention is required; on close, a diff can immediately be shown to the user so that conflicts are handled close to the time that they occur. This mechanism works best for files that are edited in multiple locations, such as documents, and poorly for files that are completely modified no matter the size of the change, such as binary files. We assert that binary files, primarily images, video, binary executables, etc. are generally created once and updated rarely and therefore generally have a low likelihood of conflict, requiring no special conflict resolution mechanism.</td></tr>
<tr><th>Problem</th><td>c. a</td></tr>
<tr><th>Solution</th><td>syntax a period usually ends a sentence, and sentences should start with a capital; doesn't apply for i.e., 
  </td></tr>
<tr><th>Trigger</th><td> '[^egs]\. [a-z]' in /Users/benjamin/.style-check.d/common-typos:9</td></tr>
</table>
 syntax a period usually ends a sentence, and sentences should start with a capital; doesn't apply for i.e., 
  (matched '[^egs]\. [a-z]' in /Users/benjamin/.style-check.d/common-typos:9)
<table id="d5e71430540f37eb5e8f0a89271d4d1ce3c6adff" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 523
, column: 285
)<div class="x"><button onclick="myFunction('d5e71430540f37eb5e8f0a89271d4d1ce3c6adff');">X</button></div></td></tr>
<tr><th>Original</th><td>Decoupling blobs from versions also provides a unique conflict detection and resolution mechanism that can reduce the impact of the increased likelihood of concurrent access due to CTO consistency. Similar to Git and OriFS ~ version trees can be implemented with data structures that perform deeper conflict detection down to the blob level. If two different blobs have been modified, automatic conflict resolution can be applied similar to Git merge. If the same blobs have been modified a manual intervention is required; on close, a diff can immediately be shown to the user so that conflicts are handled close to the time that they occur. This mechanism works best for files that are edited in multiple locations, such as documents, and poorly for files that are completely modified no matter the size of the change, such as binary files. We assert that binary files, primarily images, video, binary executables, etc. are generally created once and updated rarely and therefore generally have a low likelihood of conflict, requiring no special conflict resolution mechanism.</td></tr>
<tr><th>Problem</th><td>perform</td></tr>
<tr><th>Solution</th><td>phrase "do"
  </td></tr>
<tr><th>Trigger</th><td> 'perform' in /Users/benjamin/.style-check.d/day-gastel:154</td></tr>
</table>
 phrase "do"
  (matched 'perform' in /Users/benjamin/.style-check.d/day-gastel:154)
<table id="f815d17ea30367386326d560a940453192c1552d" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 523
, column: 119
)<div class="x"><button onclick="myFunction('f815d17ea30367386326d560a940453192c1552d');">X</button></div></td></tr>
<tr><th>Original</th><td>Decoupling blobs from versions also provides a unique conflict detection and resolution mechanism that can reduce the impact of the increased likelihood of concurrent access due to CTO consistency. Similar to Git and OriFS ~ version trees can be implemented with data structures that perform deeper conflict detection down to the blob level. If two different blobs have been modified, automatic conflict resolution can be applied similar to Git merge. If the same blobs have been modified a manual intervention is required; on close, a diff can immediately be shown to the user so that conflicts are handled close to the time that they occur. This mechanism works best for files that are edited in multiple locations, such as documents, and poorly for files that are completely modified no matter the size of the change, such as binary files. We assert that binary files, primarily images, video, binary executables, etc. are generally created once and updated rarely and therefore generally have a low likelihood of conflict, requiring no special conflict resolution mechanism.</td></tr>
<tr><th>Problem</th><td>impact of</td></tr>
<tr><th>Solution</th><td>phrase not a useful metaphor; try evaluation, success, effect, value.
  </td></tr>
<tr><th>Trigger</th><td> 'impact of' in /Users/benjamin/.style-check.d/my-rules:18</td></tr>
</table>
 phrase not a useful metaphor; try evaluation, success, effect, value.
  (matched 'impact of' in /Users/benjamin/.style-check.d/my-rules:18)
<table id="8ca5d4e8f64ce262c2bd65abfbfe528e96cf2919" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 527
, column: 468
)<div class="x"><button onclick="myFunction('8ca5d4e8f64ce262c2bd65abfbfe528e96cf2919');">X</button></div></td></tr>
<tr><th>Original</th><td>Consistency is implemented such that each replica server maintains a log of versions applied to their local view. A read access to a particular object simply looks up the latest local version of that object. Because dependency information can be embedded into a write, it is not necessary to include read accesses in the log. For example, in order to create a transaction that reads from objects~. Other notions of dependencies include implicit session dependencies, e.g. all writes are dependent on any access that occur within a minimum time threshold of each other, or explicit dependencies that are added by the application. Defining additional dependencies is the subject of future work and stretch goals related to this dissertation.</td></tr>
<tr><th>Problem</th><td>e.g. </td></tr>
<tr><th>Solution</th><td>syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  </td></tr>
<tr><th>Trigger</th><td> 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33</td></tr>
</table>
 syntax should be followed with a comma, as e.g. can be read as "for example" (thanks JZ!)
  (matched 'e\.g\.[\n ]' in /Users/benjamin/.style-check.d/common-typos:33)
<table id="3c1ef846c3e607659358bfb814397e263edbcc4e" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 527
, column: 340
)<div class="x"><button onclick="myFunction('3c1ef846c3e607659358bfb814397e263edbcc4e');">X</button></div></td></tr>
<tr><th>Original</th><td>Consistency is implemented such that each replica server maintains a log of versions applied to their local view. A read access to a particular object simply looks up the latest local version of that object. Because dependency information can be embedded into a write, it is not necessary to include read accesses in the log. For example, in order to create a transaction that reads from objects~. Other notions of dependencies include implicit session dependencies, e.g. all writes are dependent on any access that occur within a minimum time threshold of each other, or explicit dependencies that are added by the application. Defining additional dependencies is the subject of future work and stretch goals related to this dissertation.</td></tr>
<tr><th>Problem</th><td>in order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="33f579a3e8642f89749777b92959743a970d5ab5" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 527
, column: 152
)<div class="x"><button onclick="myFunction('33f579a3e8642f89749777b92959743a970d5ab5');">X</button></div></td></tr>
<tr><th>Original</th><td>Consistency is implemented such that each replica server maintains a log of versions applied to their local view. A read access to a particular object simply looks up the latest local version of that object. Because dependency information can be embedded into a write, it is not necessary to include read accesses in the log. For example, in order to create a transaction that reads from objects~. Other notions of dependencies include implicit session dependencies, e.g. all writes are dependent on any access that occur within a minimum time threshold of each other, or explicit dependencies that are added by the application. Defining additional dependencies is the subject of future work and stretch goals related to this dissertation.</td></tr>
<tr><th>Problem</th><td>simply</td></tr>
<tr><th>Solution</th><td>phrase probably isn't.
  </td></tr>
<tr><th>Trigger</th><td> 'simply' in /Users/benjamin/.style-check.d/my-rules:51</td></tr>
</table>
 phrase probably isn't.
  (matched 'simply' in /Users/benjamin/.style-check.d/my-rules:51)
<table id="a225f0170a9828e58421595bf8fda5f229e70c66" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 529
, column: 36
)<div class="x"><button onclick="myFunction('a225f0170a9828e58421595bf8fda5f229e70c66');">X</button></div></td></tr>
<tr><th>Original</th><td>Finally, a note on security in FlowFS. Although security is not a specific focus of our research, we believe that security should not be an afterthought. Because devices must be added to the system by joint consensus or through a trusted administrator, our research focuses on non-byzantine behavior. Messages between replica servers will be authenticated and signed by per-client tokens that are generated when devices are added to the topology. All communications will be secured by encrypted transport mechanisms such as TLS or SSL. The data itself can be secured by encrypting individual blobs with user-specific keys; blob replication to non-owner controlled device does not necessarily mean that the blobs can be read by all users. These steps are by no means comprehensive, but provide a baseline minimum security guarantee which could be explored further in future research.</td></tr>
<tr><th>Problem</th><td>FS. A</td></tr>
<tr><th>Solution</th><td>syntax intersentence spacing should be used if a sentence ends with an acronym: "FOO\\@."
  </td></tr>
<tr><th>Trigger</th><td> '[A-Z]{2,10}\.[ ]*[\n ][ ]*[A-Z]' in /Users/benjamin/.style-check.d/latex-checking:3</td></tr>
</table>
 syntax intersentence spacing should be used if a sentence ends with an acronym: "FOO\\@."
  (matched '[A-Z]{2,10}\.[ ]*[\n ][ ]*[A-Z]' in /Users/benjamin/.style-check.d/latex-checking:3)
<table id="a3b808187452c924038d4d551d33117b64d02a87" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 534
, column: 646
)<div class="x"><button onclick="myFunction('a3b808187452c924038d4d551d33117b64d02a87');">X</button></div></td></tr>
<tr><th>Original</th><td>Federated Consistency attempts to provide heterogenous devices in a user-centric dynamic cloud the ability to set their consistency level as needed. We propose to show that a small, strong central quorum can improve the global consistency of the system while allowing for local availability. Hierarchical consensus expands the strong central quorum, providing high throughput on the leader of the quorum by allocating multiple leaders for different objects. Together, Federated Consistency and Hierarchical Consensus provide mechanisms that deal with unstable network environments and the unique challenges a multi-user, multi-device system may encounter. However, neither Federated nor Hierarchical deal with the dynamic or mobile nature of the network; and while they provide responsiveness at the user layer, cannot take advantage of boosts in bandwidth or respond to gaps our outages.</td></tr>
<tr><th>Problem</th><td>encounter</td></tr>
<tr><th>Solution</th><td>phrase meet
  </td></tr>
<tr><th>Trigger</th><td> 'encounter' in /Users/benjamin/.style-check.d/barrass:11</td></tr>
</table>
 phrase meet
  (matched 'encounter' in /Users/benjamin/.style-check.d/barrass:11)
<table id="bb2c06ae8c6bd973668fe0ab2916aec59f624d2f" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 536
, column: 508
)<div class="x"><button onclick="myFunction('bb2c06ae8c6bd973668fe0ab2916aec59f624d2f');">X</button></div></td></tr>
<tr><th>Original</th><td>Therefore we propose the final step in the study of user-centric dynamic clouds is the real time adaptation of the network according to observed latency values. We have observed that eventually consistent nodes can change their timing parameters at will to take advantage of lower latencies or to save work in sparse network conditions. While joint consensus may be required to adapt the parameters of a consensus group, lowering the timing parameter dramatically improves throughput and commit latency and in the face of increasing latency, ensuring that the timing parameters are conservative enough such that messages aren't received out of order or such that ``leader thrashing'' occurs as much delayed heartbeat messages cause candidacies.</td></tr>
<tr><th>Problem</th><td>in the face of</td></tr>
<tr><th>Solution</th><td>phrase can be overused.  try despite?
  </td></tr>
<tr><th>Trigger</th><td> 'in the face of' in /Users/benjamin/.style-check.d/verbose-phrases:84</td></tr>
</table>
 phrase can be overused.  try despite?
  (matched 'in the face of' in /Users/benjamin/.style-check.d/verbose-phrases:84)
<table id="839e5ca4bbe4157e7fc26533065744c3fd632a12" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 545
, column: 1
)<div class="x"><button onclick="myFunction('839e5ca4bbe4157e7fc26533065744c3fd632a12');">X</button></div></td></tr>
<tr><th>Original</th><td>In order to meet the requirements of this proposal and provide substantive results for a dissertation, we propose to undertake the following projects, along with their given priority and timeline.</td></tr>
<tr><th>Problem</th><td>In order to</td></tr>
<tr><th>Solution</th><td>phrase remove "in order" and get "to"
  </td></tr>
<tr><th>Trigger</th><td> 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20</td></tr>
</table>
 phrase remove "in order" and get "to"
  (matched 'in order to' in /Users/benjamin/.style-check.d/verbose-phrases:20)
<table id="5144e9675328f0931c0f474c98c9840bf1ba4a1b" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 554
, column: 35
)<div class="x"><button onclick="myFunction('5144e9675328f0931c0f474c98c9840bf1ba4a1b');">X</button></div></td></tr>
<tr><th>Original</th><td>Implementation of the FlowFS &~ & 3-4 months \\</td></tr>
<tr><th>Problem</th><td>3-4</td></tr>
<tr><th>Solution</th><td>syntax use an endash '--' for ranges
  </td></tr>
<tr><th>Trigger</th><td> '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7</td></tr>
</table>
 syntax use an endash '--' for ranges
  (matched '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7)
<table id="48b7df514301ce3ee698563670c5075f0b51cfc5" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 555
, column: 45
)<div class="x"><button onclick="myFunction('48b7df514301ce3ee698563670c5075f0b51cfc5');">X</button></div></td></tr>
<tr><th>Original</th><td>Evaluation of FlowFS on real workloads &~ & 2-3 months \\</td></tr>
<tr><th>Problem</th><td>2-3</td></tr>
<tr><th>Solution</th><td>syntax use an endash '--' for ranges
  </td></tr>
<tr><th>Trigger</th><td> '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7</td></tr>
</table>
 syntax use an endash '--' for ranges
  (matched '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7)
<table id="5dd5947debe53d8a3e4b7f99d85a5c19f90430a0" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 558
, column: 53
)<div class="x"><button onclick="myFunction('5dd5947debe53d8a3e4b7f99d85a5c19f90430a0');">X</button></div></td></tr>
<tr><th>Original</th><td>Online optimization and consistency adaptation &~ & 2-3 months \\</td></tr>
<tr><th>Problem</th><td>2-3</td></tr>
<tr><th>Solution</th><td>syntax use an endash '--' for ranges
  </td></tr>
<tr><th>Trigger</th><td> '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7</td></tr>
</table>
 syntax use an endash '--' for ranges
  (matched '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7)
<table id="7fb0dfe25535e84432335b2838b6ed9a7571e3fa" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 560
, column: 41
)<div class="x"><button onclick="myFunction('7fb0dfe25535e84432335b2838b6ed9a7571e3fa');">X</button></div></td></tr>
<tr><th>Original</th><td>\multicolumn{2}{|l|}{\textbf{TOTAL}} & 12-16 months \\</td></tr>
<tr><th>Problem</th><td>2-1</td></tr>
<tr><th>Solution</th><td>syntax use an endash '--' for ranges
  </td></tr>
<tr><th>Trigger</th><td> '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7</td></tr>
</table>
 syntax use an endash '--' for ranges
  (matched '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7)
<table id="d9c7697ff0e5e5c1a91c9e021140854b61a90ba4" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 567
, column: 57
)<div class="x"><button onclick="myFunction('d9c7697ff0e5e5c1a91c9e021140854b61a90ba4');">X</button></div></td></tr>
<tr><th>Original</th><td>Based on preliminary work done in simulation as well as the above timeline, I propose the following paper and conference submission goals:</td></tr>
<tr><th>Problem</th><td>the above</td></tr>
<tr><th>Solution</th><td>phrase horrible phrase that must be expunged.  you might use "these" instead, but best to make the sentence stand alone.
  </td></tr>
<tr><th>Trigger</th><td> 'the above' in /Users/benjamin/.style-check.d/my-rules:34</td></tr>
</table>
 phrase horrible phrase that must be expunged.  you might use "these" instead, but best to make the sentence stand alone.
  (matched 'the above' in /Users/benjamin/.style-check.d/my-rules:34)
<table id="1aed62a3a99346e9a652cd3759739a67f9307192" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 574
, column: 75
)<div class="x"><button onclick="myFunction('1aed62a3a99346e9a652cd3759739a67f9307192');">X</button></div></td></tr>
<tr><th>Original</th><td>Federated Consistency & IEEE ICDCS 2017 & Atlanta, GA & Dec 5, 2016 & Jun 5-8 2017 \\</td></tr>
<tr><th>Problem</th><td>5-8</td></tr>
<tr><th>Solution</th><td>syntax use an endash '--' for ranges
  </td></tr>
<tr><th>Trigger</th><td> '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7</td></tr>
</table>
 syntax use an endash '--' for ranges
  (matched '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7)
<table id="3732348e897ccb16f696eeaf4e461b0269b43618" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 578
, column: 82
)<div class="x"><button onclick="myFunction('3732348e897ccb16f696eeaf4e461b0269b43618');">X</button></div></td></tr>
<tr><th>Original</th><td>User-Centric Dynamic Clouds & ACM HotStorage 2017 & Santa Clara, CA & N/A & Jul 10-11, 2017 \\</td></tr>
<tr><th>Problem</th><td>0-1</td></tr>
<tr><th>Solution</th><td>syntax use an endash '--' for ranges
  </td></tr>
<tr><th>Trigger</th><td> '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7</td></tr>
</table>
 syntax use an endash '--' for ranges
  (matched '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7)
<table id="0a237cd2bbdf4b397a363eecdcaa38d4a6a5a3c2" class="syntax">
<tr><th>File</th><td>prelim.tex (line: 586
, column: 77
)<div class="x"><button onclick="myFunction('0a237cd2bbdf4b397a363eecdcaa38d4a6a5a3c2');">X</button></div></td></tr>
<tr><th>Original</th><td>Hierarchical FlowFS & ACM SOSP 2017 & Shanghai, China & Apr 21, 2017 & Oct 29-31, 2017 \\</td></tr>
<tr><th>Problem</th><td>9-3</td></tr>
<tr><th>Solution</th><td>syntax use an endash '--' for ranges
  </td></tr>
<tr><th>Trigger</th><td> '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7</td></tr>
</table>
 syntax use an endash '--' for ranges
  (matched '[0-9]-[0-9]' in /Users/benjamin/.style-check.d/common-typos:7)
<table id="d1f6af83c5585fd9578fe6708952a0b372298a00" class="phrase">
<tr><th>File</th><td>prelim.tex (line: 601
, column: 684
)<div class="x"><button onclick="myFunction('d1f6af83c5585fd9578fe6708952a0b372298a00');">X</button></div></td></tr>
<tr><th>Original</th><td>In this proposal we have presented two novel approaches to provide responsiveness in user-centric dynamic clouds: Federated Consistency and Hierarchical Consensus, as well as stretch proposals related to automatic Adaptive Consistency. Research into these approaches is important because the number of computing devices per person is increasing and new devices are coming online via the Internet of Things. Current approaches of centralized, cloud distributed data storage provide mobile availability and durability, but do not lend themselves well to multi-user, collaborative environments. We believe that as a result, user-centric dynamic personal clouds will become increasingly important to support the increase in the number of local devices.</td></tr>
<tr><th>Problem</th><td>important to</td></tr>
<tr><th>Solution</th><td>phrase "valued by"?
  </td></tr>
<tr><th>Trigger</th><td> 'important to' in /Users/benjamin/.style-check.d/bad-words:20</td></tr>
</table>
 phrase "valued by"?
  (matched 'important to' in /Users/benjamin/.style-check.d/bad-words:20)
<table id="53c7dbb57bff592269cd875b0129eb40d2ed4db1" class="spelling">
<tr><th>File</th><td>prelim.tex (line: 605
, column: 636
)<div class="x"><button onclick="myFunction('53c7dbb57bff592269cd875b0129eb40d2ed4db1');">X</button></div></td></tr>
<tr><th>Original</th><td>We propose to show through simulation and through a file system implementation that Federated Consistency and Hierarchical Consensus together will lead to a highly available system with strong consistency guarantees. Federation will make use of a strong-central quorum to synchronize an eventual cloud, minimizing overall inconsistency in the system, while allowing eventual nodes to make progress with reduced coordination requirements. The central quorum needs to be able to scale to dozens or hundreds of nodes and so we propose Hierarchical Consensus as a means of partitioning consensus decisions to particular objects across the namespace to different leaders. This load balancing will increase throughput but also increase correctness. Together and with potential future research into online optimization we believe that this research will lead to a high quality dissertation.</td></tr>
<tr><th>Problem</th><td>namespace</td></tr>
<tr><th>Solution</th><td>spelling two words
  </td></tr>
<tr><th>Trigger</th><td> 'namespace' in /Users/benjamin/.style-check.d/networking-research:25</td></tr>
</table>
 spelling two words
  (matched 'namespace' in /Users/benjamin/.style-check.d/networking-research:25)
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript">
$('#aform').on
(
	'change', 'input[type=checkbox]', function(e) 
	{ 
		if (this.checked)
		{  
			switch(this.value){
				case 'phrase': $(".phrase").show(); break;
				case 'syntax':  $(".syntax").show(); break;
				case 'capitalize':  $(".capitalize").show(); break;
				case 'spelling':  $(".spelling").show(); break;
				case 'undefined': $(".undefined").show(); break;
			}
		} else {
			switch(this.value){
				case 'phrase': $(".phrase").hide(); break;
				case 'syntax':  $(".syntax").hide(); break;
				case 'capitalize':  $(".capitalize").hide(); break;
				case 'spelling':  $(".spelling").hide(); break;
				case 'undefined': $(".undefined").hide(); break;
			}
		}
			updateCounters();
	}	
);
$( window ).load(function() 
{
		updateCounters();
});
function myFunction(theHash){
	theHash = "#"+theHash;
	$(theHash).remove();
		updateCounters();
}

function updateCounters(){
	$("#myPhrase").html( "Phrase (" + $(".phrase").length+")"); 
	$("#mySyntax").html( "Syntax (" + $(".syntax").length+")"); 
	$("#myCapitalize").html( "Capitalize (" + $(".capitalize").length+")"); 
	$("#mySpelling").html( "Spelling (" + $(".spelling").length+")");	
	$("#myTotal").html( "Presenting " + countVisible() +" suggestions out of "+$('table').length + " identified ");	
}

function countVisible() {
	aCount=0;
	if($('#inSpelling').is(':checked')){
		aCount=aCount+$('.spelling').length;
	}
	if($('#inPhrase').is(':checked')){
		aCount=aCount+$('.phrase').length;
	}
	if($('#inSyntax').is(':checked')){
		aCount=aCount+$('.syntax').length;
	}
	if($('#inCapitalize').is(':checked')){
		aCount=aCount+$('.capitalize').length;
	}
	return aCount;
}

</script>
<p> This HTML was generated by a modified version of <a href="http://www.cs.umd.edu/~nspring/software/style-check-readme.html" target="_blank">style-check.rb</a> software.</p>
</body>
</html>"
