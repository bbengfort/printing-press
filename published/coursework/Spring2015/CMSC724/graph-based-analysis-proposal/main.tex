\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{authblk}



\begin{document}

\title{Graph-Based Analysis of Relational Data}
\date{February 15, 2015}
\author[ ]{Konstantinos Xirogiannopoulos}
\author[ ]{Benjamin Bengfort}
\affil[ ]{Department of Computer Science}
\affil[ ]{University of Maryland}
\affil[ ]{\textit{\{kostasx,bengfort\}@cs.umd.edu}}
\maketitle

% Introduction
Data models and schema can vary widely and depend particularly on the application that the data is used for. For many web based applications, the storage model of choice is relational, high performance transactional database management systems. These databases focus primarily on the selection, insertion, and updating of small numbers of rows (usually just one). In order to perform bulk analyses across entire tables, transactional DBMS systems prefer OLAP methodologies - offline, asynchronous processing. 

Recently, deep insights from machine learning and data mining are becoming integral parts of user experience in many applications from search to eCommerce. A wide array of analytical algorithms have been developed that specifically use structured graph representations of data to perform their computations. Relational databases are not well suited to performing such graph computations; a typical workflow exports data out of a relational database to a property graph model, performs analyses on the data, then imports the results of the analytics back to the operational data store.

%what Kostas proposes
We propose a compromise between relational data storage and graph query processing. We intend to create a query processing engine that takes as input a structured graph query and using a query processing plan that can be implemented on top of a relational data store generates an in-memory graph, upon which the user can run graph processing algorithms. We hope to show that graph data structures can be easily and efficiently be accessed and computed upon readily available RDBMS stores.

\section*{Relevant Work}

Creating a graph query language has been explored in \cite{he_graphs-at--time_2008} where Datalog was used to produce a query language that would operate on existing graph structures. Other graph query languages include Gremlin \cite{rodriguez_gremlin_2013} and Cypher \cite{miller_graph_2013}, though these languages focus on \textit{existing graph} data structures, and do not directly interact with relational databases. 

In the same context, researchers have also implemented automatic ways to convert the data from relational to graph databases \cite{de_virgilio_converting_2013}. The Semantic Web has made the RDF graph model popular, and exporting relational data to RDF is explored in \cite{hert_comparison_2011}. This however is very different from our work since it applies to situations where someone would want to migrate the entirety of their data to a graph database.

\section*{Proposal Description}

We propose building an expressive Domain Specific Language (DSL) based on the Datalog \cite{green_datalog_2013} declarative logic programming language, that will allow users to extract the graphs that might interest them using data in their existing RDBMS. We will focus on creating a graph data definition language (DDL) since data manipulation languages (DML) already exist for graphs (Cypher, Gremlin).  Users will be assumed to have full knowledge of and access to the database's schema, and through this DSL, they will be able to specify the Nodes and Edges that will comprise the graph. After that, they will be able to specify the algorithm they want to run, and execute it against the graph structure.

There are several research questions that we need to address. First, we need to design an appropriate DSL that is not only expressive, but also efficient to implement. Second, we need to decide how to execute a program written in that DSL by translating it to appropriate SQL. This requires us to implement ways to combine extraction of multiple graphs for efficiency. Finally, we need to develop mechanisms to execute arbitrary graph computations efficiently against the extracted graphs.

We will quantify the performance of our system by bench-marking the amount of time it will take to receive results when migrating the database to a graph database, running the algorithm there, and returning the data back to the RDBMS. This will be our baseline, and we will compare it to the latency of running a graph analysis algorithm on a graph generated by our system from the query up until the storing of the final result in the RDBMS.

In conclusion, this software will provide an intuitive and expressive way to specify hidden graphs in a relational database schema. We believe that this will not only provide users with new ways to analyze their data but it will also allow for different perspectives on data via exploring connections between them that are not immediately apparent through the adjacent relational schemas. We will show that by utilizing our system, users can get higher throughput for their analytics tasks. We are very enthusiastic to see the potential of this system unfold and are anxious to continue work on it.

\bibliographystyle{plain}
\bibliography{paper}

\end{document}